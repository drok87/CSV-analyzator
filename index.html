<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktivní Data Analyzátor s ML</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://unpkg.com/chart.js-chart-box-and-violin-plot/build/Chart.BoxPlot.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.2/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        :root {
            --bg-color: #f2f2f7;
            --text-color: #000000;
            --secondary-text-color: #8E8E93;
            --container-bg: #ffffff;
            --header-bg: #ffffff;
            --tab-bg: #e9e9eb;
            --tab-active-bg: #ffffff;
            --primary-color: #007AFF;
            --primary-hover: #006ee6;
            --danger-color: #FF3B30;
            --success-color: #34C759;
            --border-color: #e5e5ea;
            --shadow-color: rgba(0,0,0,0.05);
            --radius: 12px;

            /* Color Palette for Tabs */
            --color-overview: #007AFF;
            --color-table: #34C759;
            --color-charts: #FF9500;
            --color-comparison: #AF52DE;
            --color-analytics: #5AC8FA;
            --color-cleaning: #FF2D55;
            --color-tools: #5856D6;
            --color-export: #8E8E93;

            --color-forecast: #FFCC00;
            --color-anomaly: #FF3B30;
            --highlight-color: #ffc10740; /* Nová proměnná pro barvu zvýraznění */
        }

        .dark-mode {
            --bg-color: #000000;
            --text-color: #ffffff;
            --secondary-text-color: #8E8E93;
            --container-bg: #1C1C1E;
            --header-bg: #1C1C1E;
            --tab-bg: #2c2c2e;
            --tab-active-bg: #3a3a3c;
            --primary-color: #0A84FF;
            --primary-hover: #3593ff;
            --danger-color: #FF453A;
            --success-color: #30D158;
            --border-color: #38383a;
            --shadow-color: rgba(0,0,0,0.2);
            
            /* Dark Mode Colors */
            --color-overview: #0A84FF;
            --color-table: #30D158;
            --color-charts: #FF9F0A;
            --color-comparison: #BF5AF2;
            --color-analytics: #64D2FF;
            --color-cleaning: #FF375F;
            --color-tools: #5E5CE6;
            --color-export: #98989D;

            --color-forecast: #FFD426;
            --color-anomaly: #FF453A;
            --highlight-color: #ffc10740; /* Nová proměnná pro barvu zvýraznění */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 10px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            overflow: hidden;
            transition: background-color 0.3s;
        }

        .header {
            background: var(--header-bg);
            color: var(--text-color);
            padding: 20px 30px;
            text-align: center;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .header p {
            color: var(--secondary-text-color);
        }
        
        .theme-switcher {
            position: absolute;
            top: 20px;
            left: 20px;
            cursor: pointer;
            font-size: 1.5em;
        }
        
        .help-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            font-size: 1.5em;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: var(--tab-bg);
        }

        #uploadNewFileBtn {
            position: absolute;
            top: 20px;
            right: 70px;
            background: var(--primary-color);
            border: none;
            color: white;
            font-weight: 600;
            padding: 10px 15px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #uploadNewFileBtn:hover {
            background: var(--primary-hover);
        }

        .upload-section { padding: 40px; text-align: center; }
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 20px;
            padding: 20px;
            background: var(--bg-color);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }
        .upload-zone.loaded {
            border-style: solid;
            border-color: var(--success-color);
        }
        .upload-zone:hover { border-color: var(--primary-color); }
        .upload-icon { font-size: 2.5em; margin-bottom: 15px; }
        .file-info { font-weight: 600; margin-top: 10px; }
        .clear-file-btn {
            background: var(--danger-color);
            font-size: 0.8em;
            padding: 5px 10px;
            margin-top: 10px;
        }

        .data-section { display: none; padding: 20px; }
        .data-section.active { display: block; }

        .tabs {
            display: flex;
            background: var(--tab-bg);
            border-radius: var(--radius);
            padding: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tab {
            flex: 1 1 auto;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        .tab.active {
            color: white;
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        .tab[style*="display: none"] { display: none !important; }

        /* Tab Color Implementation */
        .tab.active[data-color="overview"] { background-color: var(--color-overview); }
        .tab.active[data-color="table"] { background-color: var(--color-table); }
        .tab.active[data-color="charts"] { background-color: var(--color-charts); }
        .tab.active[data-color="comparison"] { background-color: var(--color-comparison); }
        .tab.active[data-color="analytics"] { background-color: var(--color-analytics); }
        .tab.active[data-color="cleaning"] { background-color: var(--color-cleaning); }
        .tab.active[data-color="tools"] { background-color: var(--color-tools); }
        .tab.active[data-color="export"] { background-color: var(--color-export); }

        /* Widget Header Color Implementation */
        #overview .widget h3 { color: var(--color-overview); }
        #table .widget h3 { color: var(--color-table); }
        #charts .widget h3 { color: var(--color-charts); }
        #comparison .widget h3 { color: var(--color-comparison); }
        #analytics .widget h3 { color: var(--color-analytics); }
        #cleaning .widget h3, #cleaning .tool-section h4 { color: var(--color-cleaning); }
        #tools .widget h3, #tools .tool-section h4 { color: var(--color-tools); }
        #export .widget h3 { color: var(--color-export); }


        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .widget {
            background: var(--container-bg);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: grab;
            transition: background-color 0.3s;
        }
        .widget:active { cursor: grabbing; }
        .widget.sortable-ghost { background: rgba(0, 122, 255, 0.1); }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .stat-card {
            background: var(--tab-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: var(--radius);
            text-align: center;
        }
        .stat-number { font-size: 2em; font-weight: bold; margin-bottom: 5px; }

        .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
        .controls.sub-controls { margin-top: 10px; margin-bottom: 0; }
        input, select, button {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 14px;
            background-color: var(--tab-bg);
            color: var(--text-color);
            transition: all 0.2s ease;
        }
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        input[type="date"] { color-scheme: dark; }
        .dark-mode input[type="date"] { color-scheme: light; }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: var(--primary-hover); }
        button:disabled { background: #8E8E93; cursor: not-allowed; }
        
        .btn-secondary { background: var(--secondary-text-color); }
        .btn-secondary:hover { background: #a1a1a6; }

        .btn-success { background: var(--success-color); }
        .btn-danger { background: var(--danger-color); }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid var(--border-color); }
        th { background: var(--container-bg); color: var(--secondary-text-color); font-weight: 600; position: sticky; top: 0; text-transform: uppercase; font-size: 0.8em; }
        tr:last-child td { border-bottom: none; }
        tr:hover { background: var(--tab-bg); }
        tr.highlighted-row { background-color: var(--highlight-color) !important; }
        .table-wrapper { border: 1px solid var(--border-color); border-radius: var(--radius); max-height: 60vh; overflow-y: auto;}
        
        .pagination { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
        .pagination button { padding: 8px 12px; background: var(--container-bg); color: var(--primary-color); border: 1px solid var(--border-color); }
        .pagination button.active { background: var(--primary-color); color: white; border-color: var(--primary-color); }

        .message { padding: 15px; border-radius: var(--radius); margin: 15px 0; font-weight: 500; }
        .message.success { background: #e6f6e9; color: #2d6b3d; border: 1px solid var(--success-color); }
        .message.error { background: #ffeeed; color: #c52a21; border: 1px solid var(--danger-color); }
        .dark-mode .message.success { background: #1c3a24; color: #a4e0b3; border: 1px solid #3c7649; }
        .dark-mode .message.error { background: #4a1c24; color: #f5c6cb; border: 1px solid #8c2f39; }

        .loading { display: none; text-align: center; padding: 40px; }
        .loading-spinner { width: 40px; height: 40px; border: 4px solid var(--tab-bg); border-top: 4px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .sensor-direction { padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin: 2px; display: inline-block; }
        .direction-IN { background: var(--success-color); color: white; }
        .direction-OUT { background: var(--danger-color); color: white; }
        .direction-NA { background: var(--secondary-text-color); color: white; }
        
        .tool-section {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            margin-bottom: 25px;
            padding: 20px;
        }
        .tool-section h4 { font-size: 1.2em; margin-bottom: 10px; }
        .tool-section p { font-size: 0.95em; line-height: 1.6; }
        
        .bar-viz {
            height: 10px;
            background: var(--primary-color);
            border-radius: 5px;
        }

        .clickable-row { cursor: pointer; }
        .hour-detail td { padding: 0 !important; border-bottom: 1px solid var(--border-color); }
        
        .chart-container {
            position: relative;
            height: 50vh;
        }

        #widget-main-chart .chart-container {
            height: 300px;
        }
        
        .correlation-matrix { width: 100%; border-collapse: collapse; }
        .correlation-matrix th, .correlation-matrix td { border: 1px solid var(--border-color); padding: 8px; text-align: center; font-size: 12px; }
        .correlation-matrix th { background: var(--tab-bg); font-weight: bold; }
        .correlation-matrix td { color: white; font-weight: bold; }
        
        /* Help Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: var(--container-bg);
            margin: auto;
            padding: 30px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 800px;
            border-radius: var(--radius);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-close {
            color: var(--secondary-text-color);
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-content h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .modal-content p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .container { border-radius: 10px; }
            .header { padding: 15px; }
            .header h1 { font-size: 1.5em; }
            #uploadNewFileBtn { position: static; margin-top: 15px; display: block; width: 100%; }
            .theme-switcher { top: 15px; left: 15px; }
            .help-icon { top: 15px; right: 15px; }
            .controls { flex-direction: column; align-items: stretch; }
            .controls input, .controls select, .controls button { width: 100%; }
            .controls label { display: flex; justify-content: space-between; width: 100%; }
            .dashboard-grid { grid-template-columns: 1fr; }
            .upload-grid { grid-template-columns: 1fr; }
            .tabs { gap: 5px; }
            .tab { min-width: auto; padding: 8px 5px; font-size: 0.9em; }
            .stat-card { padding: 15px; }
            .stat-number { font-size: 1.5em; }
            .table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
            table { min-width: 500px; }
            #dataset-selector select { width: 100%; margin-top: 10px; }
            .pagination { flex-wrap: wrap; }
            button, .tab, .upload-zone { min-height: 44px; }
            .chart-container { height: 40vh; }
            
            @media (max-width: 480px) {
                .tab span { display: none; }
                .tab::before { content: attr(data-icon); }
                .tool-section { padding: 15px; }
                .widget { padding: 15px; }
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="theme-switcher" onclick="toggleTheme()">🌙</div>
            <h1>Interaktivní Data Analyzátor</h1>
            <p>Vylepšené vizualizace a dashboard</p>
            <div id="dataset-selector" style="margin-top: 15px; display: none;">
                <select onchange="selectDataset(this.value)"></select>
            </div>
            <button id="uploadNewFileBtn" style="display: none;" onclick="showUploadSection()">Nahrát další soubory</button>
            <div class="help-icon" onclick="showHelp()">❓</div>
        </div>

        <div class="upload-section" id="uploadSection">
             <h3>Nahrajte až 3 soubory pro porovnání</h3>
             <div class="upload-grid" style="margin-top: 20px;">
                <div class="upload-zone" data-index="0" onclick="document.getElementById('fileInput0').click()">
                    <div class="upload-icon">📂</div>
                    <span>Soubor 1</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput0" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 0)">
                </div>
                <div class="upload-zone" data-index="1" onclick="document.getElementById('fileInput1').click()">
                    <div class="upload-icon">📂</div>
                    <span>Soubor 2</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput1" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 1)">
                </div>
                <div class="upload-zone" data-index="2" onclick="document.getElementById('fileInput2').click()">
                    <div class="upload-icon">📂</div>
                    <span>Soubor 3</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput2" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 2)">
                </div>
             </div>
             <button id="startAnalysisBtn" style="display: none; margin-top: 20px; padding: 12px 25px; font-size: 1.1em;" onclick="startAnalysis()">Analyzovat data</button>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>Zpracovávám data...</p>
        </div>

        <div id="messageContainer"></div>

        <div class="data-section" id="dataSection">
            <div class="tabs">
                <div class="tab active" data-color="overview" onclick="switchTab('overview')">📋 Přehled</div>
                <div class="tab" data-color="table" onclick="switchTab('table')">📊 Tabulka</div>
                <div class="tab" data-color="charts" onclick="switchTab('charts')">📈 Grafy</div>
                <div class="tab" data-color="comparison" id="comparisonTab" style="display: none;" onclick="switchTab('comparison')">⚖️ Porovnání</div>
                <div class="tab" data-color="analytics" onclick="switchTab('analytics')">🔍 Pokročilé analýzy</div>
                <div class="tab" data-color="cleaning" onclick="switchTab('cleaning')">🧹 Čištění Dat</div>
                <div class="tab" data-color="tools" onclick="switchTab('tools')">🛠️ Pokročilé Nástroje</div>
                <div class="tab" data-color="export" onclick="switchTab('export')">💾 Export</div>
            </div>

            <!-- Overview -->
            <div id="overview" class="tab-content active">
                <div class="dashboard-grid" id="dashboardGrid">
                    <div class="widget" id="widget-stats">
                        <h3>Klíčové metriky</h3>
                        <div class="stats-grid" id="statsGrid"></div>
                    </div>
                    <div class="widget" id="widget-info">
                        <h3>Základní informace</h3>
                        <div id="dataInfo">Načítání...</div>
                    </div>
                     <div class="widget" id="widget-main-chart">
                        <h3>Hlavní graf</h3>
                        <div class="controls sub-controls" style="margin-bottom: 20px;">
                            <label for="overviewChartX">Osa X:</label>
                            <select id="overviewChartX" onchange="renderOverviewChart()"></select>
                            <label for="overviewChartY">Osa Y:</label>
                            <select id="overviewChartY" onchange="renderOverviewChart()"></select>
                        </div>
                        <div class="chart-container">
                           <canvas id="overviewChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Table -->
            <div id="table" class="tab-content">
                <div class="controls">
                    <input type="text" id="searchInput" placeholder="🔍 Hledat..." onkeyup="debouncedApplyFilters()">
                    <select id="itemsPerPage" onchange="changeItemsPerPage()"><option value="25">25</option><option value="50">50</option><option value="100">100</option><option value="500">500</option></select>
                    <input type="date" id="startDate" onchange="debouncedApplyFilters()">
                    <input type="date" id="endDate" onchange="debouncedApplyFilters()">
                    <button class="btn-danger" onclick="clearFilters()">Vyčistit filtry</button>
                </div>
                 <div class="controls sub-controls">
                    <button class="btn-secondary" onclick="setDateRange('last7days')">Posledních 7 dní</button>
                    <button class="btn-secondary" onclick="setDateRange('thisMonth')">Tento měsíc</button>
                    <button class="btn-secondary" onclick="setDateRange('lastMonth')">Minulý měsíc</button>
                </div>
                <div class="table-container">
                    <div class="table-wrapper">
                        <table id="dataTable">
                            <thead id="tableHead"></thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>
                <div class="pagination" id="pagination"></div>
            </div>

            <!-- Charts -->
            <div id="charts" class="tab-content">
                <div class="controls">
                    <select id="chartType" onchange="updateChartUI()">
                        <option value="bar">📊 Sloupcový</option>
                        <option value="line">📈 Čárový</option>
                        <option value="area">📈 Plošný</option>
                        <option value="pie">🥧 Koláčový</option>
                        <option value="doughnut">🍩 Prstencový</option>
                        <option value="scatter">☄️ Bodový</option>
                        <option value="boxplot">📦 Box Plot</option>
                    </select>
                    <select id="xAxis" onchange="updateChart()"><option>Vyberte...</option></select>
                    <select id="yAxis" onchange="updateChart()"><option>Vyberte...</option></select>
                </div>
                <div class="controls sub-controls" id="chartOptions">
                    <label id="trendlineOption"><input type="checkbox" id="showTrendline" onchange="updateChart()"> Zobrazit trend</label>
                    <label id="yAxis2Option"><input type="checkbox" id="enableYAxis2" onchange="updateChart()"> Druhá osa Y</label>
                    <select id="yAxis2" onchange="updateChart()"></select>
                </div>
                <div class="chart-container">
                    <canvas id="mainChart"></canvas>
                </div>
            </div>

            <!-- Comparison -->
            <div id="comparison" class="tab-content">
                <div class="controls">
                    <label for="comparisonColumn">Vyberte data pro porovnání:</label>
                    <select id="comparisonColumn" onchange="updateComparisonView()"></select>
                </div>
                <div id="comparisonContent"></div>
            </div>
            
            <!-- Analytics -->
            <div id="analytics" class="tab-content">
                <div class="controls">
                    <label for="analyticsColumn">Vyberte data pro analýzu:</label>
                    <select id="analyticsColumn" onchange="updateAdvancedAnalytics()"></select>
                </div>
                <div id="analyticsContent"></div>
            </div>
            
            <!-- Data Cleaning -->
            <div id="cleaning" class="tab-content">
                <div class="widget">
                    <h3>🧹 Nástroje pro čištění dat</h3>
                    <p>Upravte svá data před analýzou. Všechny operace jsou nevratné v rámci této relace.</p>
                </div>
                <div class="tool-section">
                    <h4>Najít a nahradit</h4>
                    <div class="controls">
                        <select id="findReplaceColumn"></select>
                        <input type="text" id="findValue" placeholder="Najít hodnotu...">
                        <input type="text" id="replaceValue" placeholder="Nahradit za...">
                        <button onclick="findAndReplace()">Nahradit</button>
                    </div>
                </div>
                <div class="tool-section">
                    <h4>Odstranit duplicitní řádky</h4>
                    <p>Prohledá celý dataset a odstraní řádky, které jsou naprosto identické.</p>
                    <div class="controls">
                        <button class="btn-danger" onclick="removeDuplicates()">Odstranit duplikáty</button>
                    </div>
                </div>
                <div class="tool-section">
                    <h4>Zpracovat chybějící hodnoty</h4>
                    <p>Vyberte sloupec a zvolte, jak naložit s řádky, které v něm mají prázdnou hodnotu.</p>
                    <div class="controls">
                        <select id="missingValuesColumn"></select>
                        <select id="missingValuesAction">
                            <option value="remove">Odstranit řádek</option>
                            <option value="fillZero">Vyplnit nulou (0)</option>
                            <option value="fillMean">Vyplnit průměrem</option>
                        </select>
                        <button onclick="handleMissingValues()">Provést</button>
                    </div>
                </div>
            </div>

            <!-- Tools -->
            <div id="tools" class="tab-content">
                <div class="widget">
                    <h3>🛠️ Pokročilé Nástroje</h3>
                    <p>Vytvořte si vlastní sloupce nebo prozkoumejte vztahy mezi daty.</p>
                </div>
                <div id="tools-content">
                    <div class="tool-section">
                        <h4>🧮 Počítané sloupce</h4>
                        <p>Vytvořte nový sloupec pomocí vzorce. Použijte názvy sloupců v hranatých závorkách, např. <code>[Cena] * [Množství]</code>.</p>
                        <div class="controls">
                            <input type="text" id="newColumnName" placeholder="Název nového sloupce">
                            <input type="text" id="newColumnFormula" placeholder="Vzorec, např. [Sloupec1] + [Sloupec2]">
                            <button onclick="createCalculatedColumn()">Vytvořit sloupec</button>
                        </div>
                    </div>
                    <div class="tool-section">
                        <h4>🔗 Korelační matice</h4>
                        <p>Zjistěte, jak silně spolu souvisí jednotlivé číselné sloupce. Hodnoty blízko 1 (zelená) značí silnou pozitivní korelaci, hodnoty blízko -1 (červená) silnou negativní korelaci.</p>
                         <div class="controls">
                            <button onclick="generateCorrelationMatrix()">Vygenerovat matici</button>
                         </div>
                        <div id="correlationMatrixContainer" class="table-wrapper" style="overflow-x: auto;"></div>
                    </div>
                    <div class="tool-section">
                        <h4>🔮 Predikce a anomálie</h4>
                        <p>Aplikace se pokusí najít anomálie a predikovat budoucí data na základě historických trendů.</p>
                        <div class="controls">
                            <select id="predictionColumn"></select>
                            <button onclick="runPredictionAndAnomalyDetection()">Spustit analýzu</button>
                        </div>
                        <div id="predictionChartContainer" class="chart-container" style="height: 400px; display:none;">
                            <canvas id="predictionChart"></canvas>
                        </div>
                    </div>
                    <!-- Nová sekce pro podmíněné formátování -->
                    <div class="tool-section">
                        <h4>🎨 Podmíněné zvýraznění dat</h4>
                        <p>Vytvořte podmínku, která v grafu zvýrazní datové body, které ji splňují.</p>
                        <div class="controls">
                            <select id="conditionColumn"></select>
                            <select id="conditionOperator">
                                <option value="=">=</option>
                                <option value=">">></option>
                                <option value="<"><</option>
                                <option value=">=">>=</option>
                                <option value="<="><=</option>
                                <option value="!=">!=</option>
                            </select>
                            <input type="text" id="conditionValue" placeholder="Hodnota...">
                            <button onclick="applyConditionalHighlighting()">Zvýraznit</button>
                        </div>
                        <p id="conditionalHighlightingMessage" style="color: var(--secondary-text-color); margin-top: 10px;"></p>
                    </div>
                </div>
            </div>

            <!-- Export -->
            <div id="export" class="tab-content">
                 <div class="controls">
                    <button class="btn-success" onclick="exportCSV()">📊 Export CSV</button>
                    <button class="btn-success" onclick="exportJSON()">🔗 Export JSON</button>
                    <button onclick="exportPDF()">🖼️ Exportovat přehled do PDF</button>
                    <button disabled title="Tato funkce vyžaduje serverovou část.">🔗 API Integrace</button>
                    <button class="btn-danger" onclick="clearAll()">🗑️ Vymazat vše</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay" onclick="hideHelp()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <span class="modal-close" onclick="hideHelp()">&times;</span>
            <h2>Nápověda k aplikaci</h2>
            
            <h3>📋 Přehled</h3>
            <p>Tato sekce poskytuje rychlý pohled na vaše data. Zobrazuje klíčové metriky (jako průměr, minimum, maximum) automaticky vybrané z nejdůležitějších sloupců a základní graf pro rychlou vizualizaci.</p>
            
            <h3>📊 Tabulka</h3>
            <p>Zde si můžete prohlížet vaše data v tabulkové formě. Můžete vyhledávat, filtrovat podle data a měnit počet zobrazených položek na stránku.</p>
            
            <h3>📈 Grafy</h3>
            <p>Vytvořte si vlastní grafy. Vyberte si typ grafu (sloupcový, čárový, koláčový...), zvolte data pro osu X a Y a vizualizujte si vztahy ve vašich datech. U čárových a bodových grafů můžete zapnout i zobrazení trendové čáry.</p>
            
            <h3>⚖️ Porovnání</h3>
            <p>Pokud nahrajete více souborů (až 3), v této sekci je můžete porovnat. Vyberte společný číselný sloupec a aplikace vám ukáže srovnávací tabulku a graf.</p>

            <h3>🔍 Pokročilé analýzy</h3>
            <p>Tato sekce nabízí specifické analýzy pro rozpoznané typy dat (např. data z chladírenských zařízení nebo senzorů). Zobrazí vám podrobnější statistiky a doporučení.</p>
            
            <h3>🧹 Čištění Dat</h3>
            <p>Upravte svá data před analýzou. Můžete hromadně nahradit hodnoty v určitém sloupci, odstranit zcela identické řádky nebo se vypořádat s chybějícími hodnotami (např. smazáním řádku nebo vyplněním průměrem).</p>

            <h3>🛠️ Pokročilé Nástroje</h3>
            <p><strong>Počítané sloupce:</strong> Vytvořte si vlastní datový sloupec pomocí matematického vzorce. Například pokud máte sloupce [Cena] a [Počet], můžete vytvořit sloupec 'Tržba' se vzorcem <code>[Cena] * [Počet]</code>.</p>
            <p><strong>Korelační matice:</strong> Tento nástroj vám ukáže, jak jsou na sobě závislé jednotlivé číselné sloupce. Zelená barva značí silnou přímou úměru, červená silnou nepřímou úměru.</p>
            <p><strong>Predikce a anomálie:</strong> Tato funkce vám ukáže predikci budoucího vývoje dat na základě lineární regrese. Zároveň se pokusí najít anomálie (odlehlé hodnoty) a vyznačí je přímo v grafu.</p>
            <p><strong>Podmíněné zvýraznění dat:</strong> Umožní vám zvýraznit datové body v grafu, které splňují vámi zvolenou podmínku, například "teplota je vyšší než 5°C".</p>

            <h3>💾 Export</h3>
            <p>Stáhněte si aktuálně zobrazená (vyfiltrovaná) data ve formátu CSV nebo JSON. Můžete také exportovat úvodní přehled do PDF souboru.</p>
        </div>
    </div>

    <script>
        // Global variables
        let datasets = [null, null, null];
        let selectedDatasetIndex = 0;
        let currentPage = 1, itemsPerPage = 50, mainChartInstance = null, overviewChartInstance = null, predictionChartInstance = null, comparisonChartInstance = null;
        let filterDebounceTimer = null;
        let chartDebounceTimer = null;
        let highlightedRows = []; // Nové pole pro uložení zvýrazněných řádků

        // Set Chart.js to Czech locale
        Chart.defaults.locale = 'cs-CZ';

        // Debounce helper function
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(filterDebounceTimer);
                filterDebounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        // Helper to get computed CSS variables
        function getCssVariable(variable) {
            return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
        }

        // Validate data helper
        function validateData(data, fileName) {
            const errors = [];
            
            if (!data || !Array.isArray(data)) {
                errors.push('Data nejsou ve správném formátu');
            } else if (data.length === 0) {
                errors.push('Soubor neobsahuje žádná data');
            } else if (data.length > 100000) {
                errors.push(`Soubor obsahuje příliš mnoho řádků (${data.length}). Maximum je 100 000`);
            } else {
                // Check if all rows have the same structure
                const firstRowKeys = Object.keys(data[0]);
                const inconsistentRows = data.filter((row, index) => {
                    const rowKeys = Object.keys(row);
                    return rowKeys.length !== firstRowKeys.length;
                });
                
                if (inconsistentRows.length > data.length * 0.1) {
                    errors.push('Více než 10% řádků má nekonzistentní strukturu');
                }
                
                // Check for minimum columns
                if (firstRowKeys.length < 2) {
                    errors.push('Data musí obsahovat alespoň 2 sloupce');
                }
            }
            
            return errors;
        }

        // --- Theme Manager ---
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
            localStorage.setItem('theme', theme);
            document.querySelector('.theme-switcher').textContent = theme === 'dark' ? '☀️' : '🌙';
            // We need a slight delay for the CSS variables to update before redrawing charts
            setTimeout(() => {
                if (mainChartInstance) updateChart();
                if (overviewChartInstance) renderOverviewChart();
            }, 50);
        }

        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                document.querySelector('.theme-switcher').textContent = '☀️';
            }
            const savedItemsPerPage = localStorage.getItem('itemsPerPage');
            if (savedItemsPerPage) {
                document.getElementById('itemsPerPage').value = savedItemsPerPage;
                itemsPerPage = parseInt(savedItemsPerPage, 10);
            }
        }

        // --- UI & Helper Functions ---
        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            const div = document.createElement('div');
            div.className = 'message ' + (type || 'success');
            div.textContent = message;
            container.appendChild(div);
            setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 5000);
        }

        function showLoading(message = 'Zpracovávám data...') { 
            const loadingDiv = document.getElementById('loading');
            loadingDiv.style.display = 'block';
            loadingDiv.querySelector('p').textContent = message;
        }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }

        function showUploadSection() {
            document.getElementById('dataSection').classList.remove('active');
            document.getElementById('uploadSection').style.display = 'block';
        }

        function startAnalysis() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dataSection').classList.add('active');
            updateUIafterFileLoad();
        }
        
        // --- Help Modal Functions ---
        function showHelp() {
            document.getElementById('helpModal').style.display = 'flex';
        }
        
        function hideHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }

        function formatHourRange(hour) {
            const startHour = String(hour).padStart(2, '0');
            const endHour = String((hour + 1) % 24).padStart(2, '0');
            return `${startHour}:00 - ${endHour}:00`;
        }

        // --- File Processing ---
        function handleFile(event, index) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.size > 50 * 1024 * 1024) { // 50MB limit
                if (!confirm('Soubor je větší než 50MB. Zpracování může trvat déle. Pokračovat?')) {
                    return;
                }
            }
            
            const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
            uploadZone.classList.add('loaded');
            uploadZone.querySelector('.file-info').textContent = 'Načítám...';
            
            showLoading();
            const extension = file.name.split('.').pop().toLowerCase();
            if (extension === 'xlsx') {
                processExcel(file, index);
            } else {
                processTextData(file, index);
            }
        }

        function processExcel(file, index) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates:true });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    processData(jsonData, index, file.name);
                } catch (error) {
                    showMessage(`❌ Chyba při zpracování Excel souboru: ${error.message}`, 'error');
                    hideLoading();
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processTextData(file, index) {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const content = e.target.result;
                    const lines = content.split('\n').filter(line => line.trim() !== '');
                    if (lines.length === 0) throw new Error("Soubor je prázdný.");

                    let processedData, fileTitle = '';
                    const firstLine = lines[0];

                    if (firstLine.includes(';EAN:BOX-')) {
                        processedData = lines.map(line => {
                            const row = {};
                            const parts = line.split(';');
                            const timePart = parts[0];
                            const timeMatch = timePart.match(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2}):(\d{3})/);
                            if (timeMatch) {
                                const [, year, month, day, hour, minute, second] = timeMatch;
                                row['timestamp'] = timePart;
                                row['datum_cas'] = `${day}.${month}.${year} ${hour}:${minute}:${second}`;
                                row['dateObject'] = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                                row['hour'] = parseInt(hour, 10);
                            }
                            for (let i = 1; i < parts.length; i++) {
                                const [key, ...valueParts] = parts[i].split(':');
                                if (key) row[key.trim()] = valueParts.join(':').trim();
                            }
                            if (!row.hasOwnProperty('direction')) row.direction = 'N/A';
                            return row;
                        });
                        processData(processedData, index, file.name);
                    } else {
                        const separators = [';', ',', '\t'];
                        let separator = ';';
                        let maxColumns = 0;
                        
                        const lineToCheck = lines.length > 1 ? lines[1] : lines[0];
                        separators.forEach(sep => {
                            const cols = lineToCheck.split(sep).length;
                            if (cols > maxColumns) {
                                maxColumns = cols;
                                separator = sep;
                            }
                        });
                        
                        let dataStartIndex = 1;
                        let columns;
                        if (lines.length > 1 && lines[0].split(separator).length < lines[1].split(separator).length) {
                            fileTitle = lines[0].trim().replace(/"/g, '');
                            columns = lines[1].split(separator).map(col => col.trim().replace(/"/g, ''));
                            dataStartIndex = 2;
                        } else {
                            fileTitle = '';
                            columns = lines[0].split(separator).map(col => col.trim().replace(/"/g, ''));
                            dataStartIndex = 1;
                        }

                        const data = [];
                        for (let i = dataStartIndex; i < lines.length; i++) {
                            const values = lines[i].split(separator).map(v => v.trim().replace(/^"|"$/g, ''));
                            if (values.length >= columns.length) {
                                const row = {};
                                columns.forEach((col, idx) => { row[col] = values[idx] || ''; });
                                data.push(row);
                            }
                        }
                        processData(data, index, file.name);
                    }
                } catch (error) {
                    showMessage(`❌ Chyba při zpracování souboru: ${error.message}`, 'error');
                    hideLoading();
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        function processData(data, index, fileName) {
            try {
                showLoading('Validuji data...');
                const validationErrors = validateData(data, fileName);
                if (validationErrors.length > 0) {
                    hideLoading();
                    showMessage(`❌ Chyby validace: ${validationErrors.join(', ')}`, 'error');
                    const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
                    uploadZone.classList.remove('loaded');
                    uploadZone.querySelector('.file-info').textContent = '';
                    return;
                }
                
                showLoading('Zpracovávám data...');
                
                const allDataRaw = data.filter(row => row && Object.values(row).some(val => val != null && val !== ''));
                let columns = allDataRaw.length > 0 ? Object.keys(allDataRaw[0]) : [];
                
                if (allDataRaw.length < 10) {
                    if (!confirm('Soubor obsahuje pouze ' + allDataRaw.length + ' řádků. Chcete pokračovat?')) {
                        hideLoading();
                        const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
                        uploadZone.classList.remove('loaded');
                        uploadZone.querySelector('.file-info').textContent = '';
                        return;
                    }
                }
                
                const dateColName = columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
                
                const allData = allDataRaw.map(originalRow => {
                    const row = { ...originalRow };
                    
                    columns.forEach(col => {
                        if(typeof row[col] === 'string') {
                            row[col] = row[col].replace(',', '.');
                        }
                    });

                    if (dateColName && row[dateColName] && !(row.dateObject instanceof Date)) {
                         const dateStr = String(row[dateColName]);
                         let date;
                         if (row[dateColName] instanceof Date) {
                             date = row[dateColName];
                         } else if (!isNaN(dateStr) && Number(dateStr) > 10000) {
                             date = new Date(Math.round((dateStr - 25569) * 86400 * 1000));
                         } else {
                             let parts = dateStr.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{1,2})/);
                             if (parts) {
                                date = new Date(parts[1], parseInt(parts[2], 10) - 1, parts[3], parts[4], parts[5], parts[6] || 0);
                             } else {
                                parts = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2}):(\d{1,2})/);
                                if (parts) {
                                   date = new Date(parts[3], parseInt(parts[2], 10) - 1, parts[1], parts[4], parts[5], parts[6] || 0);
                                } else {
                                    parts = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
                                    if (parts) date = new Date(parts[1], parseInt(parts[2], 10) - 1, parts[3]);
                                }
                             }
                         }
                         if (date && !isNaN(date)) row.dateObject = date;
                    }
                    return row;
                });
                
                datasets[index] = {
                    allData,
                    filteredData: allData,
                    columns: columns,
                    fileName,
                    currentMode: detectDataType(allData, columns).type,
                    calculatedColumns: []
                };
                
                recalculateColumnTypes(datasets[index]);
                
                selectedDatasetIndex = index;
                hideLoading();
                
                const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
                uploadZone.querySelector('.file-info').textContent = fileName;
                document.getElementById('startAnalysisBtn').style.display = 'block';
                
                showMessage(`✅ Soubor "${fileName}" úspěšně načten (${allData.length} řádků)`, 'success');
            } catch (error) {
                console.error('Chyba při zpracování dat:', error);
                showMessage(`❌ Chyba při zpracování dat: ${error.message}`, 'error');
                hideLoading();
                const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
                uploadZone.classList.remove('loaded');
                uploadZone.querySelector('.file-info').textContent = '';
            }
        }
        
        function recalculateColumnTypes(data) {
            if (!data) return;
            const numericColumns = [];
            const categoricalColumns = [];
            if (data.allData.length > 0) {
                data.columns.forEach(col => {
                    const isNumeric = data.allData.every(row => {
                        const value = String(row[col]);
                        return value === '' || value === 'null' || value === 'undefined' || !isNaN(parseFloat(value))
                    });
                    if (isNumeric && col !== 'Alarms') numericColumns.push(col);
                    else categoricalColumns.push(col);
                });
            }
            data.numericColumns = numericColumns;
            data.categoricalColumns = categoricalColumns;
        }

        function detectDataType(data, cols) {
            if (!data || data.length === 0) return { type: 'general' };
            const refrigerationCols = ['°C', 'Defrosting', 'Alarm'];
            if (cols.reduce((s, c) => s + (refrigerationCols.some(rc => c.includes(rc)) ? 1 : 0), 0) >= 2) return { type: 'refrigeration' };
            const sensorCols = ['timestamp', 'hour', 'sensor', 'EAN'];
            if (cols.reduce((s, c) => s + (sensorCols.includes(c) ? 1 : 0), 0) >= 3) return { type: 'sensor' };
            return { type: 'general' };
        }

        function updateUIafterFileLoad() {
            updateDatasetSelector();
            const loadedCount = datasets.filter(d => d).length;
            document.getElementById('comparisonTab').style.display = loadedCount > 1 ? 'block' : 'none';
            document.getElementById('uploadNewFileBtn').style.display = 'block';
            
            datasets.forEach((ds, i) => {
                const uploadZone = document.querySelector(`.upload-zone[data-index="${i}"]`);
                const fileInfo = uploadZone.querySelector('.file-info');
                if (ds) {
                    uploadZone.classList.add('loaded');
                    fileInfo.textContent = ds.fileName;
                    if (!uploadZone.querySelector('.clear-file-btn')) {
                        const btn = document.createElement('button');
                        btn.textContent = 'X';
                        btn.className = 'clear-file-btn';
                        btn.onclick = (e) => { e.stopPropagation(); clearDataset(i); };
                        uploadZone.appendChild(btn);
                    }
                } else {
                    uploadZone.classList.remove('loaded');
                    fileInfo.textContent = '';
                    const btn = uploadZone.querySelector('.clear-file-btn');
                    if(btn) btn.remove();
                }
            });
            
            updateAllVisuals();
        }

        function clearDataset(index) {
            datasets[index] = null;
            const loadedCount = datasets.filter(d => d).length;
            if (loadedCount === 0) {
                window.location.reload();
                return;
            }
            if (selectedDatasetIndex === index) {
                selectedDatasetIndex = datasets.findIndex(d => d);
            }
            updateUIafterFileLoad();
        }
        
        function selectDataset(index) {
            selectedDatasetIndex = parseInt(index, 10);
            updateAllVisuals();
        }

        function updateDatasetSelector() {
            const selectorContainer = document.getElementById('dataset-selector');
            const select = selectorContainer.querySelector('select');
            select.innerHTML = '';
            let loadedCount = 0;
            datasets.forEach((ds, i) => {
                if (ds) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = ds.fileName;
                    if (i === selectedDatasetIndex) option.selected = true;
                    select.appendChild(option);
                    loadedCount++;
                }
            });
            selectorContainer.style.display = loadedCount > 0 ? 'block' : 'none';
        }

        function getCurrentData() {
            return datasets[selectedDatasetIndex];
        }

        function updateAllVisuals() {
            if (!getCurrentData()) return;
            updateStats();
            populateOverviewChartSelectors();
            renderOverviewChart();
            updateChartUI();
            updateDataInfo();
            populateAnalyticsSelector();
            populateComparisonSelector();
            populateCleaningSelects();
            applyFilters();
            updateAdvancedAnalytics();
            populatePredictionSelector();
            populateConditionalHighlightingSelectors();
        }
        
        function getTemperatureColumn(data) {
            const preferredColumns = ['Prostor (Pb1) °C', 'Výparník (Pb2) °C', 'Return [°C]', 'Supply [°C]'];
            for (const pCol of preferredColumns) {
                const foundCol = data.columns.find(c => c.trim() === pCol);
                if (foundCol) return foundCol;
            }
            return data.columns.find(c => c.includes('°C'));
        }

        function updateStats() {
            const data = getCurrentData();
            if (!data) return;
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';
            let stats = [];

            if (data.currentMode === 'refrigeration') {
                const tempCol = getTemperatureColumn(data);
                if (tempCol) {
                    const temps = data.allData.map(row => parseFloat(String(row[tempCol]))).filter(t => !isNaN(t));
                    if (temps.length > 0) {
                        stats.push({ title: `${(temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1)}°C`, subtitle: 'Prům. teplota' });
                        stats.push({ title: `${Math.min(...temps).toFixed(1)}°C`, subtitle: 'Min. teplota' });
                        stats.push({ title: `${Math.max(...temps).toFixed(1)}°C`, subtitle: 'Max. teplota' });
                    }
                }
                const defrostCol = data.columns.find(c => c.toLowerCase().includes('odtávání') || c.toLowerCase().includes('defrosting'));
                if (defrostCol) {
                     stats.push({ title: data.allData.filter(r => String(r[defrostCol]).toLowerCase().includes('aktivní')).length, subtitle: 'Odmrazovací cykly' });
                }
            } else if (data.currentMode === 'sensor') {
                const validData = data.allData.filter(d => (d.stateCode === '1' || d.Status === '1') && d.sensor !== '0');
                stats.push({ title: new Set(validData.map(d => d.EAN)).size.toLocaleString(), subtitle: 'Unikátních beden' });
                stats.push({ title: new Set(validData.map(d => d.sensor)).size, subtitle: 'Aktivních senzorů' });
            } else {
                stats.push({ title: data.allData.length.toLocaleString(), subtitle: 'Záznamů' });
                stats.push({ title: data.columns.length, subtitle: 'Sloupců' });
            }
            statsGrid.innerHTML = stats.map(stat => `<div class="stat-card"><div class="stat-number">${stat.title}</div><div>${stat.subtitle}</div></div>`).join('');
        }

        function updateDataInfo() {
            const data = getCurrentData();
            const container = document.getElementById('dataInfo');
            let info = `<h4>Informace</h4><p><strong>Soubor:</strong> ${data.fileName}</p>`;
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            if (dateColName) {
                const dates = data.allData.map(r => r.dateObject).filter(d => d);
                if (dates.length > 0) {
                    const minDate = new Date(Math.min.apply(null, dates));
                    const maxDate = new Date(Math.max.apply(null, dates));
                    info += `<p><strong>Rozsah dat:</strong> ${minDate.toLocaleDateString('cs-CZ')} - ${maxDate.toLocaleDateString('cs-CZ')}</p>`;
                }
            }
            container.innerHTML = info;
        }

        function updateTable() {
            const data = getCurrentData();
            if (!data) return;
            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');
            const visibleCols = data.columns.filter(c => c !== 'dateObject');
            tableHead.innerHTML = '<tr>' + visibleCols.map(col => `<th>${col}</th>`).join('') + '</tr>';
            const startIndex = (currentPage - 1) * itemsPerPage;
            const pageData = data.filteredData.slice(startIndex, startIndex + itemsPerPage);
            
            // Nová logika pro aplikaci zvýraznění na řádky
            tableBody.innerHTML = pageData.map(row => {
                const isHighlighted = highlightedRows.includes(row);
                const rowClass = isHighlighted ? 'highlighted-row' : '';
                return `<tr class="${rowClass}">` + visibleCols.map(col => `<td>${row[col] === null || row[col] === undefined ? '' : row[col]}</td>`).join('') + '</tr>';
            }).join('');

            updatePagination();
        }

        function updatePagination() {
            const data = getCurrentData();
            if (!data) return;
            const totalPages = Math.ceil(data.filteredData.length / itemsPerPage);
            const pagination = document.getElementById('pagination');
            if (totalPages <= 1) { pagination.innerHTML = ''; return; }
            let html = '';
            if (currentPage > 1) html += `<button onclick="changePage(${currentPage - 1})">←</button>`;
            for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
                html += `<button class="${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
            }
            if (currentPage < totalPages) html += `<button onclick="changePage(${currentPage + 1})">→</button>`;
            pagination.innerHTML = html;
        }

        function changePage(page) { currentPage = page; updateTable(); }
        function changeItemsPerPage() { 
            itemsPerPage = parseInt(document.getElementById('itemsPerPage').value);
            localStorage.setItem('itemsPerPage', itemsPerPage);
            currentPage = 1; 
            updateTable(); 
        }
        
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            applyFilters();
        }
        
        function setDateRange(rangeType) {
            let endDate = new Date();
            let startDate = new Date();
            if (rangeType === 'last7days') {
                startDate.setDate(endDate.getDate() - 7);
            } else if (rangeType === 'thisMonth') {
                startDate.setDate(1);
            } else if (rangeType === 'lastMonth') {
                startDate = new Date(endDate.getFullYear(), endDate.getMonth() - 1, 1);
                endDate = new Date(endDate.getFullYear(), endDate.getMonth(), 0);
            }
            
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            applyFilters();
        }

        const debouncedApplyFilters = debounce(applyFilters, 300);

        function applyFilters() {
            const data = getCurrentData();
            if (!data) return;
            
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '<tr><td colspan="100%" style="text-align: center; padding: 20px;">Filtruji data...</td></tr>';
            
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            const startDate = startDateInput.value ? new Date(startDateInput.value + 'T00:00:00') : null;
            const endDate = endDateInput.value ? new Date(endDateInput.value + 'T23:59:59') : null;

            setTimeout(() => {
                data.filteredData = data.allData.filter(row => {
                    const textMatch = Object.values(row).some(val => val && val.toString().toLowerCase().includes(searchTerm));
                    const rowDate = row.dateObject;
                    if (!startDate && !endDate) return textMatch;
                    if (!rowDate) return false;
                    
                    const startMatch = !startDate || rowDate >= startDate;
                    const endMatch = !endDate || rowDate <= endDate;
                    return textMatch && startMatch && endMatch;
                });
                currentPage = 1;
                updateTable();
            }, 0);
        }
        
        function getChartColors() {
            const isDarkMode = document.body.classList.contains('dark-mode');
            return {
                textColor: isDarkMode ? '#e0e0e0' : '#333',
                gridColor: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
            };
        }
        
        function handleChartClick(event, elements, chart) {
            if (elements.length > 0) {
                const clickedIndex = elements[0].index;
                const clickedLabel = chart.data.labels[clickedIndex];
                document.getElementById('searchInput').value = clickedLabel;
                applyFilters();
                switchTab('table');
            }
        }

        // Nové funkce pro interaktivní dashboard
        function populateOverviewChartSelectors() {
            const data = getCurrentData();
            if (!data) return;

            const xSelect = document.getElementById('overviewChartX');
            const ySelect = document.getElementById('overviewChartY');

            const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            const numericCols = data.numericColumns;
            const categoricalCols = data.categoricalColumns;

            // X-Axis options
            let xOptions = '';
            if (dateCol) {
                xOptions += `<optgroup label="Časová osa">`;
                xOptions += `<option value="${dateCol}">${dateCol}</option>`;
                xOptions += `</optgroup>`;
            }
            xOptions += `<optgroup label="Kategorie">`;
            xOptions += categoricalCols.map(c => `<option value="${c}">${c}</option>`).join('');
            xOptions += `</optgroup>`;
            xSelect.innerHTML = xOptions;
            
            // Y-Axis options
            const yOptions = numericCols.map(c => `<option value="${c}">${c}</option>`).join('');
            ySelect.innerHTML = yOptions;

            // Pre-select meaningful columns
            if (dateCol) {
                xSelect.value = dateCol;
            } else if (categoricalCols.length > 0) {
                xSelect.value = categoricalCols[0];
            }

            if (numericCols.length > 0) {
                ySelect.value = numericCols[0];
            }
        }
        
        function renderOverviewChart() {
            const data = getCurrentData();
            if (!data) return;

            const ctx = document.getElementById('overviewChart').getContext('2d');
            const xCol = document.getElementById('overviewChartX').value;
            const yCol = document.getElementById('overviewChartY').value;

            if (!xCol || !yCol) {
                if (overviewChartInstance) overviewChartInstance.destroy();
                return;
            }

            let chartData, chartOptions, chartType;
            const isTimeSeries = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged')) === xCol;
            const chartDataPoints = data.allData.filter(row => row[yCol] != null && (isTimeSeries ? row.dateObject : true));

            if (isTimeSeries) {
                chartType = 'line';
                chartData = {
                    labels: chartDataPoints.map(r => r.dateObject),
                    datasets: [{
                        label: `${yCol}`,
                        data: chartDataPoints.map(r => parseFloat(String(r[yCol]))),
                        borderColor: getCssVariable('--primary-color'),
                        backgroundColor: getCssVariable('--primary-color') + '20',
                        fill: true,
                        tension: 0.2,
                        pointRadius: 0,
                    }]
                };
                chartOptions = { scales: { x: { type: 'time', time: { unit: 'day' } } } };
            } else {
                chartType = 'bar';
                const aggregatedData = chartDataPoints.reduce((acc, row) => {
                    const category = row[xCol] || 'N/A';
                    const value = parseFloat(String(row[yCol]));
                    if (!isNaN(value)) {
                       acc[category] = (acc[category] || 0) + value;
                    }
                    return acc;
                }, {});

                chartData = {
                    labels: Object.keys(aggregatedData),
                    datasets: [{
                        label: `Součet ${yCol} podle ${xCol}`,
                        data: Object.values(aggregatedData),
                        backgroundColor: getCssVariable('--primary-color'),
                    }]
                };
                chartOptions = {};
            }

            if (overviewChartInstance) overviewChartInstance.destroy();
            
            const colors = getChartColors();
            overviewChartInstance = new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    ...chartOptions,
                    plugins: { legend: { labels: { color: colors.textColor } } },
                    scales: {
                        ...chartOptions.scales,
                        x: { ...chartOptions.scales?.x, ticks: { color: colors.textColor }, grid: { color: colors.gridColor } },
                        y: { ...chartOptions.scales?.y, ticks: { color: colors.textColor }, grid: { color: colors.gridColor } }
                    },
                    onClick: (event, elements) => handleChartClick(event, elements, overviewChartInstance)
                }
            });
        }
        
        function updateChartUI() {
            const data = getCurrentData();
            if (!data) return;
            const chartType = document.getElementById('chartType').value;
            const xAxisSelect = document.getElementById('xAxis');
            const yAxisSelect = document.getElementById('yAxis');
            const yAxis2Select = document.getElementById('yAxis2');
            const trendlineOption = document.getElementById('trendlineOption');
            const yAxis2Option = document.getElementById('yAxis2Option');
            
            let xOptions = '', yOptions = '';
            
            const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));

            if (['bar', 'line', 'area'].includes(chartType)) {
                trendlineOption.style.display = 'inline-flex';
                yAxis2Option.style.display = 'inline-flex';
                yAxis2Select.style.display = 'inline-block';
            } else {
                trendlineOption.style.display = 'none';
                yAxis2Option.style.display = 'none';
                yAxis2Select.style.display = 'none';
            }

            if(chartType === 'boxplot') {
                xOptions = data.categoricalColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                trendlineOption.style.display = 'none';
                yAxis2Option.style.display = 'none';
                yAxis2Select.style.display = 'none';
            } else if (['pie', 'doughnut'].includes(chartType)) {
                xOptions = data.categoricalColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
            } else if (chartType === 'scatter') {
                xOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
            } else { // line, bar, area
                let allXOptions = [...data.categoricalColumns];
                if(dateCol) allXOptions.unshift(dateCol);
                xOptions = allXOptions.map(c => `<option value="${c}">${c}</option>`).join('');
                yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
            }
            
            xAxisSelect.innerHTML = xOptions;
            yAxisSelect.innerHTML = yOptions;
            yAxis2Select.innerHTML = yOptions;
            updateChart();
        }

        function calculateLinearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            const n = data.length;
            data.forEach(({x, y}) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        function calculateBoxPlotStats(arr) {
            if (!arr || arr.length === 0) return { min: 0, q1: 0, median: 0, q3: 0, max: 0 };
            const sorted = arr.slice().sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length / 4)];
            const median = sorted[Math.floor(sorted.length / 2)];
            const q3 = sorted[Math.floor((sorted.length * 3) / 4)];
            const iqr = q3 - q1;
            const min = Math.min(...sorted);
            const max = Math.max(...sorted);
            return { min, q1, median, q3, max };
        }


        function updateChart() {
            const data = getCurrentData();
            if (!data) return;
            
            const chartContainer = document.querySelector('#charts .chart-container');
            if (chartContainer) chartContainer.style.opacity = '0.5';
            
            clearTimeout(chartDebounceTimer);
            chartDebounceTimer = setTimeout(() => {
                renderChartNow();
            }, 100);
        }
        
        function renderChartNow() {
            const data = getCurrentData();
            if (!data) return;
            
            const ctx = document.getElementById('mainChart').getContext('2d');
            const chartType = document.getElementById('chartType').value;
            const xCol = document.getElementById('xAxis').value;
            const yCol = document.getElementById('yAxis').value;
            const showTrendline = document.getElementById('showTrendline').checked;
            const enableY2 = document.getElementById('enableYAxis2').checked;
            const yCol2 = document.getElementById('yAxis2').value;

            if (!xCol || !yCol) {
                const chartContainer = document.querySelector('#charts .chart-container');
                if (chartContainer) chartContainer.style.opacity = '1';
                return;
            }

            let labels, datasets;
            const chartData = data.filteredData;
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            const isTimeSeries = xCol === dateColName;

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: { onComplete: () => {
                    const chartContainer = document.querySelector('#charts .chart-container');
                    if (chartContainer) chartContainer.style.opacity = '1';
                }},
                scales: {},
                plugins: { legend: { labels: { color: getChartColors().textColor } } },
                onClick: (event, elements) => handleChartClick(event, elements, mainChartInstance)
            };

            if (chartType === 'boxplot') {
                const groupedData = chartData.reduce((acc, row) => {
                    const key = row[xCol] || 'N/A';
                    if (!acc[key]) acc[key] = [];
                    const value = parseFloat(row[yCol]);
                    if (!isNaN(value)) acc[key].push(value);
                    return acc;
                }, {});
                
                labels = Object.keys(groupedData);
                const boxplotData = labels.map(label => {
                    const values = groupedData[label];
                    return calculateBoxPlotStats(values);
                });

                datasets = [{
                    label: `${yCol} podle ${xCol}`,
                    data: boxplotData,
                    backgroundColor: getCssVariable('--primary-color') + '80',
                    borderColor: getCssVariable('--primary-color'),
                    borderWidth: 1,
                }];
                chartOptions.scales = {
                    x: { ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } },
                    y: { ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } }
                };

            } else {
                let values;
                if (['pie', 'doughnut'].includes(chartType)) {
                    const aggregated = chartData.reduce((acc, row) => {
                        const key = row[xCol] || 'N/A';
                        const value = parseFloat(String(row[yCol]));
                        if(!isNaN(value)) acc[key] = (acc[key] || 0) + value;
                        return acc;
                    }, {});
                    labels = Object.keys(aggregated);
                    values = Object.values(aggregated);
                } else if (isTimeSeries) {
                     labels = chartData.map(r => r.dateObject).filter(Boolean);
                     values = chartData.map(r => parseFloat(String(r[yCol])));
                } else {
                    labels = chartData.map(r => r[xCol]);
                    values = chartData.map(r => parseFloat(String(r[yCol])));
                }
                
                const isAreaOrLine = ['line', 'area'].includes(chartType);
                datasets = [{
                    label: `${yCol} podle ${xCol}`,
                    data: values,
                    backgroundColor: isAreaOrLine ? getCssVariable('--primary-color') + '20' : getCssVariable('--primary-color'),
                    borderColor: getCssVariable('--primary-color'),
                    fill: isAreaOrLine,
                    tension: 0.1,
                    yAxisID: 'y'
                }];

                if (showTrendline && (chartType === 'line' || chartType === 'scatter' || chartType === 'area')) {
                    const trendData = chartData.map((row, index) => ({
                        x: isTimeSeries && row.dateObject ? row.dateObject.getTime() : index,
                        y: parseFloat(String(row[yCol]))
                    })).filter(p => p.x != null && !isNaN(p.x) && !isNaN(p.y));
                    
                    if (trendData.length > 1) {
                        const { slope, intercept } = calculateLinearRegression(trendData);
                        datasets.push({
                            label: 'Trendová čára',
                            data: trendData.map(p => ({ x: p.x, y: slope * p.x + intercept })),
                            type: 'line',
                            borderColor: getCssVariable('--danger-color'),
                            fill: false,
                            pointRadius: 0
                        });
                    }
                }

                if (enableY2 && yCol2 && ['line', 'bar', 'area'].includes(chartType)) {
                    const values2 = chartData.map(r => parseFloat(String(r[yCol2])));
                    datasets.push({
                        label: `${yCol2} podle ${xCol}`,
                        data: values2,
                        borderColor: getCssVariable('--color-analytics'),
                        backgroundColor: getCssVariable('--color-analytics') + '80',
                        type: 'line',
                        fill: false,
                        yAxisID: 'y1'
                    });
                }
                
                if (chartType !== 'pie' && chartType !== 'doughnut') {
                    chartOptions.scales = {
                        x: { type: isTimeSeries ? 'time' : 'category', ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } },
                        y: { type: 'linear', display: true, position: 'left', ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } }
                    };
                    if (enableY2 && yCol2) {
                        chartOptions.scales.y1 = {
                            type: 'linear', display: true, position: 'right', grid: { drawOnChartArea: false },
                            ticks: { color: getCssVariable('--color-analytics') }
                        };
                    }
                }
            }
            
            if (mainChartInstance) mainChartInstance.destroy();
            
            let finalChartType = chartType;
            if (chartType === 'area') finalChartType = 'line';
            if (chartType === 'boxplot') finalChartType = 'boxplot';

            mainChartInstance = new Chart(ctx, {
                type: finalChartType,
                data: { labels, datasets },
                options: chartOptions
            });
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'analytics') {
                populateAnalyticsSelector();
                updateAdvancedAnalytics();
            } else if (tabName === 'comparison') {
                populateComparisonSelector();
                updateComparisonView();
            } else if (tabName === 'cleaning') {
                populateCleaningSelects();
            } else if (tabName === 'tools') {
                populatePredictionSelector();
                populateConditionalHighlightingSelectors();
            } else if (tabName === 'table') {
                updateTable();
            }
        }
        
        function getCommonNumericColumns() {
            const loadedDatasets = datasets.filter(d => d);
            if (loadedDatasets.length < 2) return [];

            let commonColumns = [...loadedDatasets[0].numericColumns];

            for (let i = 1; i < loadedDatasets.length; i++) {
                commonColumns = commonColumns.filter(col => loadedDatasets[i].numericColumns.includes(col));
            }
            return commonColumns;
        }

        function populateComparisonSelector() {
            const commonColumns = getCommonNumericColumns();
            const select = document.getElementById('comparisonColumn');
            const currentVal = select.value;

            const options = commonColumns.map(c => `<option value="${c}" ${c === currentVal ? 'selected' : ''}>${c}</option>`).join('');
            select.innerHTML = options;
        }

        function updateComparisonView() {
            const container = document.getElementById('comparisonContent');
            const loadedDatasets = datasets.filter(d => d);
            const selectedColumn = document.getElementById('comparisonColumn').value;

            if (loadedDatasets.length < 2) {
                container.innerHTML = `<div class="message error">Pro porovnání nahrajte alespoň dva soubory.</div>`;
                return;
            }
            if (!selectedColumn) {
                container.innerHTML = `<div class="message error">Vyberte prosím sloupec pro porovnání ze společných sloupců.</div>`;
                return;
            }

            let tableHtml = `<div class="widget"><h3>Srovnání metrik pro: ${selectedColumn}</h3><div class="table-wrapper"><table class="summary-table"><thead><tr><th>Metrika</th>`;
            loadedDatasets.forEach(ds => { tableHtml += `<th>${ds.fileName}</th>`; });
            tableHtml += '</tr></thead><tbody>';

            const metrics = ['Průměr', 'Minimum', 'Maximum', 'Součet'];
            metrics.forEach(metric => {
                tableHtml += `<tr><td><strong>${metric}</strong></td>`;
                loadedDatasets.forEach(ds => {
                    const values = ds.allData.map(row => parseFloat(row[selectedColumn])).filter(v => !isNaN(v));
                    let result = 'N/A';
                    if (values.length > 0) {
                        switch (metric) {
                            case 'Průměr': result = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2); break;
                            case 'Minimum': result = Math.min(...values).toFixed(2); break;
                            case 'Maximum': result = Math.max(...values).toFixed(2); break;
                            case 'Součet': result = values.reduce((a, b) => a + b, 0).toFixed(2); break;
                        }
                    }
                    tableHtml += `<td>${result}</td>`;
                });
                tableHtml += '</tr>';
            });
            tableHtml += '</tbody></table></div></div>';

            let chartHtml = `<div class="widget" style="margin-top:20px;"><h3>Porovnání v čase: ${selectedColumn}</h3><div class="chart-container" style="height: 400px;"><canvas id="comparisonChart"></canvas></div></div>`;
            container.innerHTML = tableHtml + chartHtml;

            const chartCtx = document.getElementById('comparisonChart').getContext('2d');
            const colors = [
                getCssVariable('--color-overview'),
                getCssVariable('--color-table'),
                getCssVariable('--color-charts')
            ];
            
            const chartDatasets = loadedDatasets.map((ds, index) => {
                const dateCol = ds.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
                if (!dateCol) return null;

                const dataPoints = ds.allData
                    .filter(row => row.dateObject && row[selectedColumn] != null)
                    .map(row => ({ x: row.dateObject, y: parseFloat(row[selectedColumn]) }));

                return {
                    label: `${ds.fileName}`,
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '33',
                    fill: false,
                    tension: 0.2,
                    pointRadius: 2
                };
            }).filter(Boolean);

            if (comparisonChartInstance) comparisonChartInstance.destroy();
            
            if (chartDatasets.length > 0) {
                const chartColors = getChartColors();
                comparisonChartInstance = new Chart(chartCtx, {
                    type: 'line',
                    data: { datasets: chartDatasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'time', time: { unit: 'day' }, ticks: { color: chartColors.textColor }, grid: { color: chartColors.gridColor } },
                            y: { ticks: { color: chartColors.textColor }, grid: { color: chartColors.gridColor } }
                        },
                        plugins: { legend: { labels: { color: chartColors.textColor } } }
                    }
                });
            } else {
                 document.getElementById('comparisonChart').parentElement.innerHTML = '<p style="text-align:center; padding: 20px;">Pro vytvoření časového grafu je potřeba datový sloupec s datem ve všech souborech.</p>';
            }
        }
        
        function populateAnalyticsSelector() {
            const data = getCurrentData();
            if (!data) return;
            const select = document.getElementById('analyticsColumn');
            const currentVal = select.value;
            const options = data.numericColumns.map(c => `<option value="${c}" ${c === currentVal ? 'selected' : ''}>${c}</option>`).join('');
            select.innerHTML = options;
        }

        function updateAdvancedAnalytics() {
            const data = getCurrentData();
            if (!data) return;
            
            populateAnalyticsSelector();
            
            const container = document.getElementById('analyticsContent');
            const selectedColumn = document.getElementById('analyticsColumn').value;

            if (data.currentMode === 'refrigeration') {
                 if(selectedColumn) container.innerHTML = generateRefrigerationAnalytics(selectedColumn);
                 else container.innerHTML = `<div class="message error">Vyberte prosím číselný sloupec pro analýzu.</div>`;
            }
            else if (data.currentMode === 'sensor') container.innerHTML = generateSensorAnalytics();
            else container.innerHTML = `<div style="text-align:center; padding: 40px;">Pro tento typ dat není dostupná žádná pokročilá analýza.</div>`;
        }

        function generateRefrigerationAnalytics(tempCol) {
            const data = getCurrentData();
            const alarmCol = data.columns.find(c => c.toLowerCase().includes('alarm'));
            const defrostCol = data.columns.find(c => c.toLowerCase().includes('odtávání') || c.toLowerCase().includes('defrosting'));
            
            let tempStatsHtml = '<p>Teplotní data nebyla nalezena.</p>';
            let timeOutOfRangeHtml = '';

            if (tempCol) {
                const temps = data.allData.map(row => ({
                    value: parseFloat(String(row[tempCol])),
                    date: row.dateObject
                })).filter(t => !isNaN(t.value) && t.date);
                
                if (temps.length > 0) {
                    tempStatsHtml = `
                        <p><strong>Průměr:</strong> ${(temps.map(t=>t.value).reduce((a, b) => a + b, 0) / temps.length).toFixed(2)}°C</p>
                        <p><strong>Minimum:</strong> ${Math.min(...temps.map(t=>t.value)).toFixed(2)}°C</p>
                        <p><strong>Maximum:</strong> ${Math.max(...temps.map(t=>t.value)).toFixed(2)}°C</p>
                    `;
                    const safeTemp = -18;
                    let outOfRangeMillis = 0;
                    for(let i = 1; i < temps.length; i++) {
                        if (temps[i-1].value > safeTemp && temps[i].value > safeTemp) {
                            const timeDiff = temps[i].date.getTime() - temps[i-1].date.getTime();
                            if (timeDiff < 3600000) outOfRangeMillis += timeDiff;
                        }
                    }
                    const totalMinutes = Math.round(outOfRangeMillis / (1000 * 60));
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    timeOutOfRangeHtml = `<p><strong>Čas nad -18°C:</strong> <span style="font-weight:bold; color: var(--danger-color);">${hours}h ${minutes}m</span></p>`;
                }
            }

            let stateAnalysisHtml = '';
            if (defrostCol) {
                 const defrostingTime = data.allData.filter(r => String(r[defrostCol]).toLowerCase().includes('aktivní')).length * 5;
                 stateAnalysisHtml += `<p><strong>Celkový čas odmrazování:</strong> ${Math.floor(defrostingTime / 60)}h ${defrostingTime % 60}m</p>`;
            }
             if (alarmCol) {
                const totalAlarms = data.allData.filter(r => r[alarmCol] !== '0' && r[alarmCol] !== '' && r[alarmCol] != null).length;
                stateAnalysisHtml += `<p><strong>Počet alarmů:</strong> <span style="color: ${totalAlarms > 0 ? 'var(--danger-color)' : 'var(--success-color)'}; font-weight: bold;">${totalAlarms}</span></p>`;
            }

            return `<div class="widget"><h3>🌡️ Analýza chladírny: ${data.fileName}</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div style="background: var(--bg-color); padding: 15px; border-radius: 8px;">
                        <h4>Teplotní statistiky (${tempCol || 'N/A'})</h4>
                        ${tempStatsHtml}
                        ${timeOutOfRangeHtml}
                    </div>
                    <div style="background: var(--bg-color); padding: 15px; border-radius: 8px;">
                        <h4>Analýza stavů</h4>
                        ${stateAnalysisHtml}
                    </div>
                </div>
            </div>`;
        }

        function generateSensorAnalytics() {
            const data = getCurrentData();
            const validData = data.allData.filter(d => (d.stateCode === '1' || d.Status === '1') && d.sensor !== '0');
            const hourlyData = {};
            validData.forEach(d => {
                if (d.hour !== undefined && d.hour !== null) {
                    hourlyData[d.hour] = (hourlyData[d.hour] || 0) + 1;
                }
            });

            const totalValid = validData.length;
            const hourlyStats = Object.entries(hourlyData).map(([hour, count]) => ({
                hour: parseInt(hour),
                count,
                percentage: (count / totalValid * 100).toFixed(1)
            })).sort((a,b) => a.hour - b.hour);

            const maxHour = hourlyStats.reduce((max, h) => h.count > max.count ? h : max, {count: -1, hour: -1});
            const minHour = hourlyStats.reduce((min, h) => h.count < min.count ? h : min, {count: Infinity, hour: -1});
            
            let summaryHtml = `<p>Nebylo nalezeno dostatek dat pro analýzu vytíženosti.</p>`;
            if (maxHour.hour !== -1 && minHour.hour !== -1) {
                summaryHtml = `
                    <p><strong>Celkem záznamů:</strong> ${data.allData.length} (${totalValid} validních)</p>
                    <p><strong>Nejaktivnější hodina:</strong> ${formatHourRange(maxHour.hour)} (${maxHour.count} beden)</p>
                    <p><strong>Nejméně aktivní hodina:</strong> ${formatHourRange(minHour.hour)} (${minHour.count} beden)</p>
                    <p><strong>Doporučení:</strong> Provoz je nejvyšší v ${formatHourRange(maxHour.hour)}. Zvažte posílení zdrojů v tomto čase. Naopak, v ${formatHourRange(minHour.hour)} je provoz minimální.</p>
                `;
            }

            let html = `<div class="widget" style="margin-bottom:20px;"><h3>📈 Souhrn analýzy</h3>${summaryHtml}</div>`;
            
            html += `<div class="widget"><h3>📋 Detailní přehled</h3><div class="table-wrapper"><table class="summary-table">
                <thead><tr><th>Hodina</th><th>Počet beden</th><th>Podíl z celku</th><th>Vizuální přehled</th></tr></thead><tbody>`;

            hourlyStats.forEach(h => {
                html += `<tr class="clickable-row" onclick="toggleHourDetail(${h.hour})">
                    <td>${formatHourRange(h.hour)}</td>
                    <td>${h.count}</td>
                    <td>${h.percentage}%</td>
                    <td><div class="bar-viz" style="width: ${h.percentage}%;"></div></td>
                </tr>
                <tr id="detail-for-hour-${h.hour}" class="hour-detail" style="display: none;"><td colspan="4"></td></tr>`;
            });

            html += `</tbody></table></div></div>`;
            return html;
        }

        function toggleHourDetail(hour) {
            const detailRow = document.getElementById(`detail-for-hour-${hour}`);
            if (!detailRow) return;

            if (detailRow.style.display === 'none') {
                if (detailRow.querySelector('td').innerHTML === '') {
                    const detailHtml = generateHourDetailHtml(hour);
                    detailRow.querySelector('td').innerHTML = detailHtml;
                }
                detailRow.style.display = 'table-row';
            } else {
                detailRow.style.display = 'none';
            }
        }

        function generateHourDetailHtml(hour) {
            const data = getCurrentData();
            const recordsForHour = data.allData
                .filter(row => row.hour === hour && (row.stateCode === '1' || row.Status === '1'))
                .sort((a, b) => a.timestamp.localeCompare(b.timestamp));

            if (recordsForHour.length === 0) {
                return '<p style="padding: 10px; text-align: center;">Pro tuto hodinu nebyly nalezeny žádné validní záznamy.</p>';
            }

            let html = `<div style="padding: 15px; background: var(--bg-color);"><table class="summary-table">
                        <thead><tr><th>Přesný čas</th><th>EAN</th><th>Senzor</th><th>Směr</th></tr></thead><tbody>`;
            
            recordsForHour.forEach(d => {
                const dirClass = d.direction === 'IN' ? 'direction-IN' : (d.direction === 'OUT' ? 'direction-OUT' : 'direction-NA');
                html += `<tr>
                    <td>${(d.datum_cas || '').split(' ')[1] || ''}</td>
                    <td>${d.EAN || ''}</td>
                    <td>${d.sensor || ''}</td>
                    <td><span class="sensor-direction ${dirClass}">${d.direction || 'N/A'}</span></td>
                 </tr>`;
            });

            html += `</tbody></table></div>`;
            return html;
        }
        
        // --- Data Cleaning Tools ---
        function populateCleaningSelects() {
            const data = getCurrentData();
            if (!data) return;
            const findReplaceSelect = document.getElementById('findReplaceColumn');
            const missingValuesSelect = document.getElementById('missingValuesColumn');
            const options = data.columns.map(c => `<option value="${c}">${c}</option>`).join('');
            findReplaceSelect.innerHTML = options;
            missingValuesSelect.innerHTML = options;
        }

        function findAndReplace() {
            const data = getCurrentData();
            if (!data) return;
            const column = document.getElementById('findReplaceColumn').value;
            const findValue = document.getElementById('findValue').value;
            const replaceValue = document.getElementById('replaceValue').value;

            if (!column || findValue === '') {
                return showMessage('❌ Vyberte sloupec a zadejte hodnotu, kterou chcete najít.', 'error');
            }
            
            let changes = 0;
            data.allData.forEach(row => {
                if(String(row[column]) === findValue) {
                    row[column] = replaceValue;
                    changes++;
                }
            });

            recalculateColumnTypes(data);
            updateAllVisuals();
            showMessage(`✅ Nahrazeno ${changes} hodnot ve sloupci '${column}'.`, 'success');
        }

        function removeDuplicates() {
            const data = getCurrentData();
            if (!data) return;
            const originalCount = data.allData.length;
            const uniqueRowsAsStrings = new Set(data.allData.map(row => JSON.stringify(row)));
            const uniqueRows = Array.from(uniqueRowsAsStrings).map(str => JSON.parse(str));
            const removedCount = originalCount - uniqueRows.length;

            // After JSON stringify/parse, Date objects become strings. We need to convert them back.
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            if (dateColName) {
                uniqueRows.forEach(row => {
                    if (row.dateObject && typeof row.dateObject === 'string') {
                        const parsedDate = new Date(row.dateObject);
                        if (!isNaN(parsedDate)) {
                            row.dateObject = parsedDate;
                        }
                    }
                });
            }
            
            data.allData = uniqueRows;
            
            updateAllVisuals();
            showMessage(`✅ Odstraněno ${removedCount} duplicitních řádků.`, 'success');
        }

        function handleMissingValues() {
            const data = getCurrentData();
            if (!data) return;
            const column = document.getElementById('missingValuesColumn').value;
            const action = document.getElementById('missingValuesAction').value;
            const originalCount = data.allData.length;
            let mean = 0;

            if (action === 'fillMean') {
                if (!data.numericColumns.includes(column)) {
                    return showMessage('❌ Pro výpočet průměru musí být sloupec číselný.', 'error');
                }
                const values = data.allData.map(row => parseFloat(row[column])).filter(v => !isNaN(v));
                mean = values.reduce((a, b) => a + b, 0) / values.length;
            }
            
            if (action === 'remove') {
                data.allData = data.allData.filter(row => row[column] !== '' && row[column] !== null || row[column] !== undefined);
            } else {
                data.allData.forEach(row => {
                    if (row[column] === '' || row[column] === null || row[column] === undefined) {
                        if (action === 'fillZero') row[column] = 0;
                        if (action === 'fillMean') row[column] = mean.toFixed(2);
                    }
                });
            }
            
            const changes = originalCount - data.allData.length;
            recalculateColumnTypes(data);
            updateAllVisuals();
            showMessage(`✅ Operace dokončena. Změněno/odstraněno ${changes > 0 ? changes : 'mnoho'} řádků.`, 'success');
        }


        // --- Advanced Tools ---
        function createCalculatedColumn() {
            const data = getCurrentData();
            if (!data) return;
            
            const newName = document.getElementById('newColumnName').value.trim();
            const formula = document.getElementById('newColumnFormula').value.trim();

            if (!newName || !formula) {
                return showMessage("❌ Zadejte název i vzorec pro nový sloupec.", "error");
            }
            if (data.columns.includes(newName)) {
                return showMessage("❌ Sloupec s tímto názvem již existuje.", "error");
            }

            try {
                data.allData.forEach(row => {
                    let tempFormula = formula;
                    const columnNames = formula.match(/\[.*?\]/g) || [];
                    
                    for(const col of columnNames) {
                        const colName = col.substring(1, col.length - 1);
                        const value = parseFloat(row[colName]);
                        if (isNaN(value)) throw new Error(`Nečíselná hodnota ve sloupci '${colName}'.`);
                        tempFormula = tempFormula.replace(col, value);
                    }
                    const result = new Function(`return ${tempFormula}`)();
                    row[newName] = result.toFixed(2);
                });

                data.columns.push(newName);
                recalculateColumnTypes(data);
                updateAllVisuals();
                showMessage(`✅ Sloupec '${newName}' byl úspěšně vytvořen.`, 'success');

            } catch(e) {
                showMessage(`❌ Chyba ve vzorci: ${e.message}`, 'error');
            }
        }

        function generateCorrelationMatrix() {
            const data = getCurrentData();
            if (!data) return;
            const container = document.getElementById('correlationMatrixContainer');
            container.innerHTML = '<div class="loading-spinner" style="margin: 20px auto;"></div><p style="text-align:center;">Počítám korelaci...</p>';
            
            setTimeout(() => {
                const numericCols = data.numericColumns;
                const matrix = [];

                for(let i = 0; i < numericCols.length; i++) {
                    matrix[i] = [];
                    for(let j = 0; j < numericCols.length; j++) {
                        if (i === j) {
                            matrix[i][j] = 1;
                        } else {
                            const col1 = data.allData.map(row => parseFloat(row[numericCols[i]])).filter(v => !isNaN(v));
                            const col2 = data.allData.map(row => parseFloat(row[numericCols[j]])).filter(v => !isNaN(v));
                            matrix[i][j] = calculateCorrelation(col1, col2);
                        }
                    }
                }
                renderCorrelationMatrix(matrix, numericCols);
            }, 100);
        }
        
        function calculateCorrelation(x, y) {
            const n = Math.min(x.length, y.length);
            if (n === 0) return 0;

            const meanX = x.slice(0, n).reduce((a, b) => a + b) / n;
            const meanY = y.slice(0, n).reduce((a, b) => a + b) / n;

            let num = 0, denX = 0, denY = 0;

            for (let i = 0; i < n; i++) {
                num += (x[i] - meanX) * (y[i] - meanY);
                denX += Math.pow(x[i] - meanX, 2);
                denY += Math.pow(y[i] - meanY, 2);
            }
            
            const den = Math.sqrt(denX) * Math.sqrt(denY);
            return den === 0 ? 0 : num / den;
        }

        function renderCorrelationMatrix(matrix, columns) {
            const container = document.getElementById('correlationMatrixContainer');
            let html = '<table class="correlation-matrix"><thead><tr><th>&nbsp;</th>';
            columns.forEach(col => html += `<th>${col}</th>`);
            html += '</tr></thead><tbody>';

            matrix.forEach((row, i) => {
                html += `<tr><th>${columns[i]}</th>`;
                row.forEach(val => {
                    const color = getCorrelationColor(val);
                    html += `<td style="background-color: ${color};">${val.toFixed(2)}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function getCorrelationColor(value) {
            // value is between -1 and 1
            const h = (1 - value) * 60; // 0 (red) to 120 (green)
            const l = Math.abs(value) * 40 + 25; // lightness from 25% to 65%
            return `hsl(${h}, 90%, ${l}%)`;
        }

        // --- Nová funkcionalita: Predikce a anomálie ---

        function populatePredictionSelector() {
            const data = getCurrentData();
            if (!data) return;
            const select = document.getElementById('predictionColumn');
            const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            const numericCols = data.numericColumns.filter(c => c !== dateCol);

            let options = '';
            if (dateCol) {
                options = `<optgroup label="Časová řada">`;
                options += numericCols.map(c => `<option value="${c}">${c}</option>`).join('');
                options += `</optgroup>`;
            } else {
                options = numericCols.map(c => `<option value="${c}">${c}</option>`).join('');
            }
            
            select.innerHTML = options;
        }

        function runPredictionAndAnomalyDetection() {
            const data = getCurrentData();
            if (!data) {
                showMessage('❌ Nejprve nahrajte data.', 'error');
                return;
            }

            const selectedCol = document.getElementById('predictionColumn').value;
            const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            
            if (!selectedCol || !dateCol) {
                showMessage('❌ Pro predikci je nutné mít sloupec s datem a číselný sloupec.', 'error');
                return;
            }
            
            showLoading('Spouštím analýzu dat...');
            document.getElementById('predictionChartContainer').style.display = 'none';

            setTimeout(() => {
                const plotData = data.allData
                    .map(row => ({
                        x: row.dateObject,
                        y: parseFloat(String(row[selectedCol]))
                    }))
                    .filter(p => p.x && !isNaN(p.y))
                    .sort((a,b) => a.x - b.x);

                if (plotData.length < 10) {
                    hideLoading();
                    showMessage('❌ Pro predikci je potřeba alespoň 10 datových bodů.', 'error');
                    return;
                }

                // Jednoduchá lineární regrese pro predikci
                const regressionData = plotData.map((p, i) => ({ x: i, y: p.y }));
                const { slope, intercept } = calculateLinearRegression(regressionData);

                const lastIndex = regressionData.length - 1;
                const lastDate = plotData[lastIndex].x;
                const predictionPoints = [];
                const futurePointsCount = Math.floor(plotData.length * 0.2); // Predikce 20% budoucích dat
                
                for (let i = 1; i <= futurePointsCount; i++) {
                    const futureIndex = lastIndex + i;
                    const futureDate = new Date(lastDate.getTime() + (i * (lastDate.getTime() - plotData[lastIndex - 1].x.getTime())));
                    const predictedValue = slope * futureIndex + intercept;
                    predictionPoints.push({ x: futureDate, y: predictedValue });
                }

                // Z-score pro detekci anomálií
                const values = plotData.map(p => p.y);
                const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
                const stdDev = Math.sqrt(values.map(v => (v - mean) ** 2).reduce((sum, s) => sum + s, 0) / values.length);
                const anomalies = plotData.filter(p => Math.abs((p.y - mean) / stdDev) > 3);

                renderPredictionChart(plotData, predictionPoints, anomalies, selectedCol);
                hideLoading();
                showMessage('✅ Analýza predikce a anomálií dokončena.', 'success');
            }, 100);
        }

        function renderPredictionChart(plotData, predictionData, anomalies, selectedCol) {
            const ctx = document.getElementById('predictionChart').getContext('2d');
            const chartColors = getChartColors();

            const datasets = [{
                label: selectedCol,
                data: plotData,
                borderColor: getCssVariable('--primary-color'),
                backgroundColor: getCssVariable('--primary-color') + '20',
                fill: false,
                tension: 0.1,
                pointRadius: 2,
            }, {
                label: 'Predikce',
                data: predictionData,
                borderColor: getCssVariable('--color-forecast'),
                borderDash: [5, 5],
                fill: false,
                tension: 0.1,
                pointRadius: 0,
            }];

            if (anomalies.length > 0) {
                datasets.push({
                    label: 'Anomálie',
                    data: anomalies,
                    pointBackgroundColor: getCssVariable('--color-anomaly'),
                    pointRadius: 6,
                    pointStyle: 'crossRot',
                    type: 'scatter',
                    showLine: false,
                });
            }
            
            const annotations = anomalies.map(a => ({
                type: 'point',
                xValue: a.x,
                yValue: a.y,
                display: true,
                backgroundColor: getCssVariable('--color-anomaly'),
                pointRadius: 6,
                pointStyle: 'triangle',
            }));

            if (predictionChartInstance) predictionChartInstance.destroy();
            
            document.getElementById('predictionChartContainer').style.display = 'block';

            predictionChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { type: 'time', ticks: { color: chartColors.textColor }, grid: { color: chartColors.gridColor } },
                        y: { ticks: { color: chartColors.textColor }, grid: { color: chartColors.gridColor } }
                    },
                    plugins: { 
                        legend: { labels: { color: chartColors.textColor } },
                        annotation: { annotations }
                    },
                }
            });
        }

        // --- Nová funkcionalita: Podmíněné zvýraznění dat ---
        function populateConditionalHighlightingSelectors() {
            const data = getCurrentData();
            if (!data) return;
            const select = document.getElementById('conditionColumn');
            const numericCols = data.numericColumns;
            const options = numericCols.map(c => `<option value="${c}">${c}</option>`).join('');
            select.innerHTML = options;
        }

        function applyConditionalHighlighting() {
            const data = getCurrentData();
            if (!data) {
                showMessage('❌ Nejprve nahrajte data.', 'error');
                return;
            }
            
            const column = document.getElementById('conditionColumn').value;
            const operator = document.getElementById('conditionOperator').value;
            const valueInput = document.getElementById('conditionValue').value;
            const value = parseFloat(valueInput);

            if (!column || valueInput === '' || isNaN(value)) {
                showMessage('❌ Vyberte sloupec a zadejte platnou číselnou hodnotu.', 'error');
                return;
            }
            
            // 1. Zjistit, které řádky splňují podmínku
            highlightedRows = data.filteredData.filter(row => {
                const cellValue = parseFloat(row[column]);
                if (isNaN(cellValue)) return false;

                switch(operator) {
                    case '=': return cellValue === value;
                    case '>': return cellValue > value;
                    case '<': return cellValue < value;
                    case '>=': return cellValue >= value;
                    case '<=': return cellValue <= value;
                    case '!=': return cellValue !== value;
                    default: return false;
                }
            });
            
            // 2. Přepnout na záložku tabulky a aktualizovat zobrazení
            switchTab('table');
            // updateTable() se volá automaticky při přepnutí záložky, ale pro jistotu
            updateTable();

            // 3. Vytvořit dodatečný dataset pro graf na záložce 'Charts'
            // Tato část se přesune do renderChartNow, ale potřebujeme data
            const xCol = document.getElementById('xAxis').value;
            const yCol = document.getElementById('yAxis').value;

            if (!xCol || !yCol) {
                // If chart is not set up, just highlight table and show a message
                showMessage(`✅ Zvýrazněno ${highlightedRows.length} řádků v tabulce, které splňují podmínku: ${column} ${operator} ${valueInput}.`, 'success');
                return;
            }
            
            // Tady musíme graf vygenerovat znovu, aby se promítly změny
            renderChartWithHighlighting(column, operator, valueInput);

            document.getElementById('conditionalHighlightingMessage').textContent = `✅ Zvýrazněno ${highlightedRows.length} řádků v tabulce a bodech v grafu, které splňují podmínku: ${column} ${operator} ${valueInput}.`;
            showMessage(`✅ Zvýrazněno ${highlightedRows.length} řádků v tabulce. Přejděte na záložku "Grafy" pro vizualizaci.`, 'success');

        }

        function renderChartWithHighlighting(conditionColumn, conditionOperator, conditionValue) {
            const data = getCurrentData();
            if (!data) return;

            const ctx = document.getElementById('mainChart').getContext('2d');
            const chartType = document.getElementById('chartType').value;
            const xCol = document.getElementById('xAxis').value;
            const yCol = document.getElementById('yAxis').value;
            const showTrendline = document.getElementById('showTrendline').checked;
            const enableY2 = document.getElementById('enableYAxis2').checked;
            const yCol2 = document.getElementById('yAxis2').value;

            const chartData = data.filteredData;
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            const isTimeSeries = xCol === dateColName;

            // Destroy existing chart instance
            if (mainChartInstance) mainChartInstance.destroy();
            
            // Generate datasets based on the condition
            let labels, mainDataPoints, highlightDataPoints;
            
            // Helper function to check condition
            const checkCondition = (row) => {
                const cellValue = parseFloat(row[conditionColumn]);
                if (isNaN(cellValue)) return false;
                const value = parseFloat(conditionValue);
                switch(conditionOperator) {
                    case '=': return cellValue === value;
                    case '>': return cellValue > value;
                    case '<': return cellValue < value;
                    case '>=': return cellValue >= value;
                    case '<=': return cellValue <= value;
                    case '!=': return cellValue !== value;
                    default: return false;
                }
            };
            
            labels = chartData.map(r => isTimeSeries ? r.dateObject : r[xCol]);
            mainDataPoints = chartData.map((r, index) => {
                return {
                    x: isTimeSeries ? r.dateObject : r[xCol],
                    y: parseFloat(String(r[yCol])),
                    highlight: checkCondition(r)
                };
            });
            
            const datasets = [{
                label: yCol,
                data: mainDataPoints.filter(p => !p.highlight).map(p => ({ x: p.x, y: p.y })),
                borderColor: getCssVariable('--primary-color'),
                backgroundColor: getCssVariable('--primary-color') + '20',
                fill: false,
                tension: 0.1,
                pointRadius: 2,
                type: 'line', // For non-time-series, might need to adjust
            }, {
                label: `Zvýrazněno: ${conditionColumn} ${conditionOperator} ${conditionValue}`,
                data: mainDataPoints.filter(p => p.highlight).map(p => ({ x: p.x, y: p.y })),
                borderColor: getCssVariable('--danger-color'),
                backgroundColor: getCssVariable('--danger-color'),
                fill: false,
                tension: 0.1,
                pointRadius: 6,
                pointStyle: 'rectRot',
                showLine: false,
                type: 'scatter',
            }];

            if (showTrendline) {
                const trendData = mainDataPoints.map((p, i) => ({
                    x: isTimeSeries ? p.x.getTime() : i,
                    y: p.y
                })).filter(p => p.x != null && !isNaN(p.x) && !isNaN(p.y));

                if (trendData.length > 1) {
                    const { slope, intercept } = calculateLinearRegression(trendData);
                    datasets.push({
                        label: 'Trendová čára',
                        data: trendData.map(p => ({ x: p.x, y: slope * p.x + intercept })),
                        type: 'line',
                        borderColor: getCssVariable('--secondary-text-color'),
                        fill: false,
                        pointRadius: 0
                    });
                }
            }

            // Create the new chart
            mainChartInstance = new Chart(ctx, {
                type: chartType,
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { type: isTimeSeries ? 'time' : 'category', ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } },
                        y: { ticks: { color: getChartColors().textColor }, grid: { color: getChartColors().gridColor } }
                    },
                    plugins: {
                        legend: { labels: { color: getChartColors().textColor } },
                    }
                }
            });
        }


        // --- Export & Reset ---
        function exportCSV() {
            const data = getCurrentData();
            if (!data || data.filteredData.length === 0) return showMessage('❌ Žádná data k exportu', 'error');
            const visibleCols = data.columns.filter(c => c !== 'dateObject');
            let csv = visibleCols.join(',') + '\n';
            data.filteredData.forEach(row => {
                csv += visibleCols.map(col => `"${(row[col] || '').toString().replace(/"/g, '""')}"`).join(',') + '\n';
            });
            downloadFile(csv, `export_${data.fileName}.csv`, 'text/csv');
        }

        function exportJSON() {
            const data = getCurrentData();
            if (!data || data.filteredData.length === 0) return showMessage('❌ Žádná data k exportu', 'error');
            const dataToExport = data.filteredData.map(row => {
                const newRow = {...row};
                delete newRow.dateObject;
                return newRow;
            });
            const content = JSON.stringify(dataToExport, null, 2);
            downloadFile(content, `export_${data.fileName}.json`, 'application/json');
        }

        async function exportPDF() {
            try {
                showLoading('Generuji PDF report...');
                showMessage('Připravuji PDF export...', 'success');
                
                const { jsPDF } = window.jspdf;
                const dashboard = document.getElementById('dashboardGrid');
                
                dashboard.style.opacity = '0.7';
                
                const canvas = await html2canvas(dashboard, {
                    backgroundColor: document.body.classList.contains('dark-mode') ? '#1e1e1e' : '#ffffff',
                    scale: 2
                });
                
                dashboard.style.opacity = '1';
                
                const imgData = canvas.toDataURL('image/png');
                
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
                
                pdf.setFontSize(22);
                pdf.text('Report analýzy dat', pdfWidth / 2, 20, { align: 'center' });
                pdf.setFontSize(12);
                pdf.text(`Soubor: ${getCurrentData().fileName}`, 15, 30);
                pdf.text(`Datum exportu: ${new Date().toLocaleString('cs-CZ')}`, 15, 36);

                pdf.addImage(imgData, 'PNG', 15, 45, pdfWidth - 30, pdfHeight - 30);
                
                pdf.save(`report_${getCurrentData().fileName}.pdf`);
                
                hideLoading();
                showMessage('✅ PDF report úspěšně vygenerován', 'success');
            } catch (error) {
                hideLoading();
                showMessage(`❌ Chyba při generování PDF: ${error.message}`, 'error');
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function resetApp() { window.location.reload(); }
        function clearAll() { if (confirm('Opravdu chcete vymazat všechna data a začít znovu?')) resetApp(); }
        
        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
             applySavedTheme();
             document.getElementById('uploadNewFileBtn').addEventListener('click', showUploadSection);
             
             new Sortable(document.getElementById('dashboardGrid'), {
                animation: 150,
                ghostClass: 'sortable-ghost'
            });
        });
        window.addEventListener('error', e => showMessage(`❌ Nastala chyba: ${e.message || 'Neznámá chyba'}`, 'error'));
    </script>
</body>
</html>
