<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktivn√≠ Data Analyz√°tor s ML</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <!-- Opraveno: Pou≈æit√≠ spr√°vn√©ho souboru pro prohl√≠≈æeƒç (cdn.js) -->
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/locale/cs/cdn.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --bg-color: #f2f2f7;
            --text-color: #000000;
            --secondary-text-color: #8E8E93;
            --container-bg: #ffffff;
            --header-bg: #ffffff;
            --tab-bg: #e9e9eb;
            --tab-active-bg: #ffffff;
            --primary-color: #007AFF;
            --primary-hover: #006ee6;
            --danger-color: #FF3B30;
            --success-color: #34C759;
            --border-color: #e5e5ea;
            --shadow-color: rgba(0,0,0,0.05);
            --radius: 12px;
        }

        .dark-mode {
            --bg-color: #000000;
            --text-color: #ffffff;
            --secondary-text-color: #8E8E93;
            --container-bg: #1C1C1E;
            --header-bg: #1C1C1E;
            --tab-bg: #2c2c2e;
            --tab-active-bg: #3a3a3c;
            --primary-color: #0A84FF;
            --primary-hover: #3593ff;
            --danger-color: #FF453A;
            --success-color: #30D158;
            --border-color: #38383a;
            --shadow-color: rgba(0,0,0,0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 10px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            overflow: hidden;
            transition: background-color 0.3s;
        }

        .header {
            background: var(--header-bg);
            color: var(--text-color);
            padding: 20px 30px;
            text-align: center;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .header p {
            color: var(--secondary-text-color);
        }
        
        .theme-switcher {
            position: absolute;
            top: 20px;
            left: 20px;
            cursor: pointer;
            font-size: 1.5em;
        }

        #uploadNewFileBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            border: none;
            color: white;
            font-weight: 600;
            padding: 10px 15px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #uploadNewFileBtn:hover {
            background: var(--primary-hover);
        }

        .upload-section { padding: 40px; text-align: center; }
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 20px;
            padding: 20px;
            background: var(--bg-color);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }
        .upload-zone.loaded {
            border-style: solid;
            border-color: var(--success-color);
        }
        .upload-zone:hover { border-color: var(--primary-color); }
        .upload-icon { font-size: 2.5em; margin-bottom: 15px; }
        .file-info { font-weight: 600; margin-top: 10px; }
        .clear-file-btn {
            background: var(--danger-color);
            font-size: 0.8em;
            padding: 5px 10px;
            margin-top: 10px;
        }

        .data-section { display: none; padding: 20px; }
        .data-section.active { display: block; }

        .tabs {
            display: flex;
            background: var(--tab-bg);
            border-radius: var(--radius);
            padding: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tab {
            flex: 1 1 auto;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        .tab.active {
            background: var(--tab-active-bg);
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        .tab[style*="display: none"] { display: none !important; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .widget {
            background: var(--container-bg);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: grab;
            transition: background-color 0.3s;
        }
        .widget:active { cursor: grabbing; }
        .widget.sortable-ghost { background: rgba(0, 122, 255, 0.1); }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .stat-card {
            background: var(--tab-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: var(--radius);
            text-align: center;
        }
        .stat-number { font-size: 2em; font-weight: bold; margin-bottom: 5px; }

        .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
        .controls.sub-controls { margin-top: 10px; margin-bottom: 0; }
        input, select, button {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 14px;
            background-color: var(--tab-bg);
            color: var(--text-color);
            transition: all 0.2s ease;
        }
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        input[type="date"] { color-scheme: dark; }
        .dark-mode input[type="date"] { color-scheme: light; }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: var(--primary-hover); }
        button:disabled { background: #8E8E93; cursor: not-allowed; }
        
        .btn-secondary { background: var(--secondary-text-color); }
        .btn-secondary:hover { background: #a1a1a6; }

        .btn-success { background: var(--success-color); }
        .btn-danger { background: var(--danger-color); }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid var(--border-color); }
        th { background: var(--container-bg); color: var(--secondary-text-color); font-weight: 600; position: sticky; top: 0; text-transform: uppercase; font-size: 0.8em; }
        tr:last-child td { border-bottom: none; }
        tr:hover { background: var(--tab-bg); }
        .table-wrapper { border: 1px solid var(--border-color); border-radius: var(--radius); max-height: 60vh; overflow-y: auto;}
        
        .pagination { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
        .pagination button { padding: 8px 12px; background: var(--container-bg); color: var(--primary-color); border: 1px solid var(--border-color); }
        .pagination button.active { background: var(--primary-color); color: white; border-color: var(--primary-color); }

        .message { padding: 15px; border-radius: var(--radius); margin: 15px 0; font-weight: 500; }
        .message.success { background: #e6f6e9; color: #2d6b3d; border: 1px solid var(--success-color); }
        .message.error { background: #ffeeed; color: #c52a21; border: 1px solid var(--danger-color); }
        .dark-mode .message.success { background: #1c3a24; color: #a4e0b3; border: 1px solid #3c7649; }
        .dark-mode .message.error { background: #4a1c24; color: #f5c6cb; border: 1px solid #8c2f39; }

        .loading { display: none; text-align: center; padding: 40px; }
        .loading-spinner { width: 40px; height: 40px; border: 4px solid var(--tab-bg); border-top: 4px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .sensor-direction { padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin: 2px; display: inline-block; }
        .direction-IN { background: var(--success-color); color: white; }
        .direction-OUT { background: var(--danger-color); color: white; }
        .direction-NA { background: var(--secondary-text-color); color: white; }
        
        .ml-section {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            margin-bottom: 25px;
            padding: 20px;
        }
        .ml-section h4 { font-size: 1.2em; color: var(--primary-color); margin-bottom: 10px; }
        .ml-section p { font-size: 0.95em; line-height: 1.6; }
        
        .bar-viz {
            height: 10px;
            background: var(--primary-color);
            border-radius: 5px;
        }

        .clickable-row { cursor: pointer; }
        .hour-detail td { padding: 0 !important; border-bottom: 1px solid var(--border-color); }
        
        .chart-container {
            position: relative;
            height: 50vh;
        }

        #widget-main-chart .chart-container {
            height: 300px;
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .container { border-radius: 10px; }
            .header { padding: 15px; }
            .header h1 { font-size: 1.5em; }
            #uploadNewFileBtn { position: static; margin-top: 15px; display: block; width: 100%; }
            .theme-switcher { top: 15px; left: 15px; }
            .controls { flex-direction: column; align-items: stretch; }
            .dashboard-grid { grid-template-columns: 1fr; }
            .upload-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="theme-switcher" onclick="toggleTheme()">üåô</div>
            <h1>Interaktivn√≠ Data Analyz√°tor</h1>
            <p>Vylep≈°en√© vizualizace a dashboard</p>
            <div id="dataset-selector" style="margin-top: 15px; display: none;">
                <select onchange="selectDataset(this.value)"></select>
            </div>
            <button id="uploadNewFileBtn" style="display: none;" onclick="showUploadSection()">Nahr√°t dal≈°√≠ soubory</button>
        </div>

        <div class="upload-section" id="uploadSection">
             <h3>Nahrajte a≈æ 3 soubory pro porovn√°n√≠</h3>
             <div class="upload-grid" style="margin-top: 20px;">
                <div class="upload-zone" data-index="0" onclick="document.getElementById('fileInput0').click()">
                    <div class="upload-icon">üìÇ</div>
                    <span>Soubor 1</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput0" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 0)">
                </div>
                <div class="upload-zone" data-index="1" onclick="document.getElementById('fileInput1').click()">
                    <div class="upload-icon">üìÇ</div>
                    <span>Soubor 2</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput1" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 1)">
                </div>
                <div class="upload-zone" data-index="2" onclick="document.getElementById('fileInput2').click()">
                    <div class="upload-icon">üìÇ</div>
                    <span>Soubor 3</span>
                    <p class="file-info"></p>
                    <input type="file" id="fileInput2" style="display: none;" accept=".xlsx,.csv,.tsv,.json,.txt" onchange="handleFile(event, 2)">
                </div>
             </div>
             <button id="startAnalysisBtn" style="display: none; margin-top: 20px; padding: 12px 25px; font-size: 1.1em;" onclick="startAnalysis()">Analyzovat data</button>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>Zpracov√°v√°m data...</p>
        </div>

        <div id="messageContainer"></div>

        <div class="data-section" id="dataSection">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('overview')">üìã P≈ôehled</div>
                <div class="tab" onclick="switchTab('table')">üìä Tabulka</div>
                <div class="tab" onclick="switchTab('charts')">üìà Grafy</div>
                <div class="tab" id="comparisonTab" style="display: none;" onclick="switchTab('comparison')">‚öñÔ∏è Porovn√°n√≠</div>
                <div class="tab" onclick="switchTab('analytics')">üîç Pokroƒçil√© anal√Ωzy</div>
                <div class="tab" onclick="switchTab('ml')">ü§ñ Machine Learning</div>
                <div class="tab" onclick="switchTab('export')">üíæ Export</div>
            </div>

            <!-- Overview -->
            <div id="overview" class="tab-content active">
                <div class="dashboard-grid" id="dashboardGrid">
                    <div class="widget" id="widget-stats">
                        <h3>Kl√≠ƒçov√© metriky</h3>
                        <div class="stats-grid" id="statsGrid"></div>
                    </div>
                    <div class="widget" id="widget-info">
                        <h3>Z√°kladn√≠ informace</h3>
                        <div id="dataInfo">Naƒç√≠t√°n√≠...</div>
                    </div>
                     <div class="widget" id="widget-main-chart">
                        <h3>Hlavn√≠ graf</h3>
                        <div class="chart-container">
                           <canvas id="overviewChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Table -->
            <div id="table" class="tab-content">
                <div class="controls">
                    <input type="text" id="searchInput" placeholder="üîç Hledat..." onkeyup="applyFilters()">
                    <select id="itemsPerPage" onchange="changeItemsPerPage()"><option value="25">25</option><option value="50">50</option><option value="100">100</option><option value="500">500</option></select>
                    <input type="date" id="startDate" onchange="applyFilters()">
                    <input type="date" id="endDate" onchange="applyFilters()">
                    <button class="btn-danger" onclick="clearFilters()">Vyƒçistit filtry</button>
                </div>
                 <div class="controls sub-controls">
                    <button class="btn-secondary" onclick="setDateRange('last7days')">Posledn√≠ch 7 dn√≠</button>
                    <button class="btn-secondary" onclick="setDateRange('thisMonth')">Tento mƒõs√≠c</button>
                    <button class="btn-secondary" onclick="setDateRange('lastMonth')">Minul√Ω mƒõs√≠c</button>
                </div>
                <div class="table-container">
                    <div class="table-wrapper">
                        <table id="dataTable">
                            <thead id="tableHead"></thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>
                <div class="pagination" id="pagination"></div>
            </div>

            <!-- Charts -->
            <div id="charts" class="tab-content">
                <div class="controls">
                    <select id="chartType" onchange="updateChartUI()"><option value="bar">üìä Sloupcov√Ω</option><option value="line">üìà ƒå√°rov√Ω</option><option value="pie">ü•ß Kol√°ƒçov√Ω</option><option value="doughnut">üç© Prstencov√Ω</option><option value="scatter">‚òÑÔ∏è Bodov√Ω</option></select>
                    <select id="xAxis" onchange="updateChart()"><option>Vyberte...</option></select>
                    <select id="yAxis" onchange="updateChart()"><option>Vyberte...</option></select>
                    <label><input type="checkbox" id="showTrendline" onchange="updateChart()"> Zobrazit trend</label>
                </div>
                <div class="chart-container">
                    <canvas id="mainChart"></canvas>
                </div>
            </div>

            <!-- Comparison -->
            <div id="comparison" class="tab-content">
                <div id="comparisonContent"></div>
            </div>
            
            <!-- Analytics -->
            <div id="analytics" class="tab-content">
                <div class="controls">
                    <label for="analyticsColumn">Vyberte data pro anal√Ωzu:</label>
                    <select id="analyticsColumn" onchange="updateAdvancedAnalytics()"></select>
                </div>
                <div id="analyticsContent"></div>
            </div>
            
            <!-- Machine Learning -->
            <div id="ml" class="tab-content">
                <div class="widget">
                    <h3>ü§ñ Machine Learning Anal√Ωzy</h3>
                    <p>Tato sekce nab√≠z√≠ pokroƒçil√© anal√Ωzy s vyu≈æit√≠m model≈Ø strojov√©ho uƒçen√≠.</p>
                </div>
                <div id="ml-content">
                    <div class="ml-section">
                        <h4>üìà Predikce trend≈Ø</h4>
                        <p>Na z√°kladƒõ historick√Ωch dat v ƒçasov√© ≈ôadƒõ model p≈ôedpov√≠ budouc√≠ v√Ωvoj.</p>
                        <div class="controls">
                            <select id="predictionColumn"><option>Vyberte sloupec...</option></select>
                            <input type="number" value="10" min="1">
                            <button onclick="predictTrend()">Spustit predikci</button>
                        </div>
                        <div id="predictionResult" class="chart-container" style="display:none; height: 300px; margin-top: 15px;"></div>
                    </div>
                    <div class="ml-section">
                        <h4>‚ö†Ô∏è Detekce anom√°li√≠</h4>
                        <p>Model prohled√° data a identifikuje neobvykl√© hodnoty (outliery) pomoc√≠ statistick√© metody IQR.</p>
                         <div class="controls">
                            <select id="anomalyColumn"><option>Vyberte sloupec...</option></select>
                            <button onclick="findAnomalies()">Naj√≠t anom√°lie</button>
                         </div>
                        <div id="anomalyResults"></div>
                    </div>
                </div>
            </div>

            <!-- Export -->
            <div id="export" class="tab-content">
                 <div class="controls">
                    <button class="btn-success" onclick="exportCSV()">üìä Export CSV</button>
                    <button class="btn-success" onclick="exportJSON()">üîó Export JSON</button>
                    <button onclick="exportPDF()">üñºÔ∏è Exportovat p≈ôehled do PDF</button>
                    <button disabled title="Tato funkce vy≈æaduje serverovou ƒç√°st.">üîó API Integrace</button>
                    <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Vymazat v≈°e</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let datasets = [null, null, null];
        let selectedDatasetIndex = 0;
        let currentPage = 1, itemsPerPage = 50, mainChartInstance = null, overviewChartInstance = null, predictionChartInstance = null, comparisonChartInstance = null;

        // --- Theme Manager ---
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
            localStorage.setItem('theme', theme);
            document.querySelector('.theme-switcher').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            if (mainChartInstance) updateChart();
            if (overviewChartInstance) renderOverviewChart();
        }

        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                document.querySelector('.theme-switcher').textContent = '‚òÄÔ∏è';
            }
            const savedItemsPerPage = localStorage.getItem('itemsPerPage');
            if (savedItemsPerPage) {
                document.getElementById('itemsPerPage').value = savedItemsPerPage;
                itemsPerPage = parseInt(savedItemsPerPage, 10);
            }
        }

        // --- UI & Helper Functions ---
        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            const div = document.createElement('div');
            div.className = 'message ' + (type || 'success');
            div.textContent = message;
            container.appendChild(div);
            setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 5000);
        }

        function showLoading() { document.getElementById('loading').style.display = 'block'; }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }

        function showUploadSection() {
            document.getElementById('dataSection').classList.remove('active');
            document.getElementById('uploadSection').style.display = 'block';
        }

        function startAnalysis() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dataSection').classList.add('active');
            updateUIafterFileLoad();
        }

        function formatHourRange(hour) {
            const startHour = String(hour).padStart(2, '0');
            const endHour = String((hour + 1) % 24).padStart(2, '0');
            return `${startHour}:00 - ${endHour}:00`;
        }

        // --- File Processing ---
        function handleFile(event, index) {
            const file = event.target.files[0];
            if (!file) return;
            
            const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
            uploadZone.classList.add('loaded');
            uploadZone.querySelector('.file-info').textContent = 'Naƒç√≠t√°m...';
            
            showLoading();
            const extension = file.name.split('.').pop().toLowerCase();
            if (extension === 'xlsx') {
                processExcel(file, index);
            } else {
                processTextData(file, index);
            }
        }

        function processExcel(file, index) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates:true });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    processData(jsonData, index, file.name);
                } catch (error) {
                    showMessage(`‚ùå Chyba p≈ôi zpracov√°n√≠ Excel souboru: ${error.message}`, 'error');
                    hideLoading();
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processTextData(file, index) {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const content = e.target.result;
                    const lines = content.split('\n').filter(line => line.trim() !== '');
                    if (lines.length === 0) throw new Error("Soubor je pr√°zdn√Ω.");

                    let processedData, fileTitle = '';
                    const firstLine = lines[0];

                    if (firstLine.includes(';EAN:BOX-')) {
                        processedData = lines.map(line => {
                            const row = {};
                            const parts = line.split(';');
                            const timePart = parts[0];
                            const timeMatch = timePart.match(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2}):(\d{3})/);
                            if (timeMatch) {
                                const [, year, month, day, hour, minute, second] = timeMatch;
                                row['timestamp'] = timePart;
                                row['datum_cas'] = `${day}.${month}.${year} ${hour}:${minute}:${second}`;
                                row['dateObject'] = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                                row['hour'] = parseInt(hour, 10);
                            }
                            for (let i = 1; i < parts.length; i++) {
                                const [key, ...valueParts] = parts[i].split(':');
                                if (key) row[key.trim()] = valueParts.join(':').trim();
                            }
                            if (!row.hasOwnProperty('direction')) row.direction = 'N/A';
                            return row;
                        });
                        processData(processedData, index, file.name);
                    } else {
                        const separators = [';', ',', '\t'];
                        let separator = ';';
                        let maxColumns = 0;
                        
                        const lineToCheck = lines.length > 1 ? lines[1] : lines[0];
                        separators.forEach(sep => {
                            const cols = lineToCheck.split(sep).length;
                            if (cols > maxColumns) {
                                maxColumns = cols;
                                separator = sep;
                            }
                        });
                        
                        let dataStartIndex = 1;
                        let columns;
                        if (lines.length > 1 && lines[0].split(separator).length < lines[1].split(separator).length) {
                            fileTitle = lines[0].trim().replace(/"/g, '');
                            columns = lines[1].split(separator).map(col => col.trim().replace(/"/g, ''));
                            dataStartIndex = 2;
                        } else {
                            fileTitle = '';
                            columns = lines[0].split(separator).map(col => col.trim().replace(/"/g, ''));
                        }

                        const data = [];
                        for (let i = dataStartIndex; i < lines.length; i++) {
                            const values = lines[i].split(separator).map(v => v.trim().replace(/^"|"$/g, ''));
                            if (values.length >= columns.length) {
                                const row = {};
                                columns.forEach((col, idx) => { row[col] = values[idx] || ''; });
                                data.push(row);
                            }
                        }
                        processData(data, index, file.name);
                    }
                } catch (error) {
                    showMessage(`‚ùå Chyba p≈ôi zpracov√°n√≠ souboru: ${error.message}`, 'error');
                    hideLoading();
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        function processData(data, index, fileName) {
            const allData = data.filter(row => row && Object.values(row).some(val => val != null && val !== ''));
            const columns = allData.length > 0 ? Object.keys(allData[0]) : [];
            
            const numericColumns = [];
            const categoricalColumns = [];
            if (allData.length > 0) {
                columns.forEach(col => {
                    const isNumeric = allData.every(row => {
                        const value = String(row[col]).replace(',', '.');
                        return value === '' || value === null || !isNaN(parseFloat(value))
                    });
                    if (isNumeric && col !== 'Alarms') numericColumns.push(col);
                    else categoricalColumns.push(col);
                });
            }

            // Convert comma decimal to dot decimal and parse dates
            const dateColName = columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            allData.forEach(row => {
                numericColumns.forEach(col => {
                    if (typeof row[col] === 'string') {
                        row[col] = row[col].replace(',', '.');
                    }
                });
                if (dateColName && row[dateColName] && !(row.dateObject instanceof Date)) {
                     const dateStr = String(row[dateColName]);
                     let date;
                     
                     if (row[dateColName] instanceof Date) {
                         date = row[dateColName];
                     }
                     // Handle Excel's numeric date format
                     else if (!isNaN(dateStr) && Number(dateStr) > 10000) { // Basic check for excel date number
                         date = new Date(Math.round((dateStr - 25569) * 86400 * 1000));
                     } else {
                         // Handle "YYYY-MM-DD HH:MM:SS"
                         let parts = dateStr.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{1,2})/);
                         if (parts) {
                            date = new Date(parts[1], parseInt(parts[2], 10) - 1, parts[3], parts[4], parts[5], parts[6] || 0);
                         } else {
                            // Handle "DD/MM/YYYY HH:MM:S"
                            parts = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2}):(\d{1,2})/);
                            if (parts) {
                               date = new Date(parts[3], parseInt(parts[2], 10) - 1, parts[1], parts[4], parts[5], parts[6] || 0);
                            } else {
                                // Handle YYYY-MM-DD
                                parts = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
                                if (parts) {
                                    date = new Date(parts[1], parseInt(parts[2], 10) - 1, parts[3]);
                                }
                            }
                         }
                     }
                     if (date && !isNaN(date)) {
                         row.dateObject = date;
                     }
                }
            });


            datasets[index] = {
                allData,
                filteredData: allData,
                columns,
                numericColumns,
                categoricalColumns,
                fileName,
                currentMode: detectDataType(allData, columns).type
            };
            
            selectedDatasetIndex = index;
            
            hideLoading();
            
            const uploadZone = document.querySelector(`.upload-zone[data-index="${index}"]`);
            uploadZone.querySelector('.file-info').textContent = fileName;
            document.getElementById('startAnalysisBtn').style.display = 'block';
        }

        function detectDataType(data, cols) {
            if (!data || data.length === 0) return { type: 'general' };
            const refrigerationCols = ['¬∞C', 'Defrosting', 'Alarm'];
            if (cols.reduce((s, c) => s + (refrigerationCols.some(rc => c.includes(rc)) ? 1 : 0), 0) >= 2) return { type: 'refrigeration' };
            const sensorCols = ['timestamp', 'hour', 'sensor', 'EAN'];
            if (cols.reduce((s, c) => s + (sensorCols.includes(c) ? 1 : 0), 0) >= 3) return { type: 'sensor' };
            return { type: 'general' };
        }

        function updateUIafterFileLoad() {
            updateDatasetSelector();
            const loadedCount = datasets.filter(d => d).length;
            document.getElementById('comparisonTab').style.display = loadedCount > 1 ? 'block' : 'none';
            
            datasets.forEach((ds, i) => {
                const uploadZone = document.querySelector(`.upload-zone[data-index="${i}"]`);
                const fileInfo = uploadZone.querySelector('.file-info');
                if (ds) {
                    uploadZone.classList.add('loaded');
                    fileInfo.textContent = ds.fileName;
                    if (!uploadZone.querySelector('.clear-file-btn')) {
                        const btn = document.createElement('button');
                        btn.textContent = 'X';
                        btn.className = 'clear-file-btn';
                        btn.onclick = (e) => { e.stopPropagation(); clearDataset(i); };
                        uploadZone.appendChild(btn);
                    }
                } else {
                    uploadZone.classList.remove('loaded');
                    fileInfo.textContent = '';
                    const btn = uploadZone.querySelector('.clear-file-btn');
                    if(btn) btn.remove();
                }
            });
            
            updateAllVisuals();
        }

        function clearDataset(index) {
            datasets[index] = null;
            const loadedCount = datasets.filter(d => d).length;
            if (loadedCount === 0) {
                window.location.reload();
                return;
            }
            if (selectedDatasetIndex === index) {
                selectedDatasetIndex = datasets.findIndex(d => d);
            }
            updateUIafterFileLoad();
        }
        
        function selectDataset(index) {
            selectedDatasetIndex = parseInt(index, 10);
            updateAllVisuals();
        }

        function updateDatasetSelector() {
            const selectorContainer = document.getElementById('dataset-selector');
            const select = selectorContainer.querySelector('select');
            select.innerHTML = '';
            let loadedCount = 0;
            datasets.forEach((ds, i) => {
                if (ds) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = ds.fileName;
                    if (i === selectedDatasetIndex) option.selected = true;
                    select.appendChild(option);
                    loadedCount++;
                }
            });
            selectorContainer.style.display = loadedCount > 0 ? 'block' : 'none';
        }

        function getCurrentData() {
            return datasets[selectedDatasetIndex];
        }

        function updateAllVisuals() {
            if (!getCurrentData()) return;
            updateStats();
            renderOverviewChart();
            updateChartUI();
            updateDataInfo();
            updateMLSelects();
            populateAnalyticsSelector();
            applyFilters();
            updateAdvancedAnalytics();
        }
        
        // Function to get the most relevant temperature column
        function getTemperatureColumn(data) {
            const preferredColumns = ['Return [¬∞C]', 'Supply [¬∞C]'];
            for (const pCol of preferredColumns) {
                const foundCol = data.columns.find(c => c.trim() === pCol);
                if (foundCol) return foundCol;
            }
            // Fallback to the first column with ¬∞C if preferred are not found
            return data.columns.find(c => c.includes('¬∞C'));
        }

        function updateStats() {
            const data = getCurrentData();
            if (!data) return;
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = ''; // Clear previous stats
            let stats = [];

            if (data.currentMode === 'refrigeration') {
                const tempCol = getTemperatureColumn(data);
                if (tempCol) {
                    const temps = data.allData.map(row => parseFloat(String(row[tempCol]).replace(',', '.'))).filter(t => !isNaN(t));
                    if (temps.length > 0) {
                        stats.push({ title: `${(temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1)}¬∞C`, subtitle: 'Pr≈Øm. teplota' });
                        stats.push({ title: `${Math.min(...temps).toFixed(1)}¬∞C`, subtitle: 'Min. teplota' });
                        stats.push({ title: `${Math.max(...temps).toFixed(1)}¬∞C`, subtitle: 'Max. teplota' });
                    }
                }
                const defrostCol = data.columns.find(c => c.toLowerCase().includes('defrosting'));
                if (defrostCol) {
                     stats.push({ title: data.allData.filter(r => String(r[defrostCol]).toLowerCase() === 'true').length, subtitle: 'Odmrazovac√≠ cykly' });
                }
            } else if (data.currentMode === 'sensor') {
                const validData = data.allData.filter(d => (d.stateCode === '1' || d.Status === '1') && d.sensor !== '0');
                stats.push({ title: new Set(validData.map(d => d.EAN)).size.toLocaleString(), subtitle: 'Unik√°tn√≠ch beden' });
                stats.push({ title: new Set(validData.map(d => d.sensor)).size, subtitle: 'Aktivn√≠ch senzor≈Ø' });
            } else {
                stats.push({ title: data.allData.length.toLocaleString(), subtitle: 'Z√°znam≈Ø' });
                stats.push({ title: data.columns.length, subtitle: 'Sloupc≈Ø' });
            }
            statsGrid.innerHTML = stats.map(stat => `<div class="stat-card"><div class="stat-number">${stat.title}</div><div>${stat.subtitle}</div></div>`).join('');
        }

        function updateDataInfo() {
            const data = getCurrentData();
            const container = document.getElementById('dataInfo');
            let info = `<h4>Informace</h4><p><strong>Soubor:</strong> ${data.fileName}</p>`;
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            if (dateColName) {
                const dates = data.allData.map(r => r.dateObject).filter(d => d);
                if (dates.length > 0) {
                    const minDate = new Date(Math.min.apply(null, dates));
                    const maxDate = new Date(Math.max.apply(null, dates));
                    info += `<p><strong>Rozsah dat:</strong> ${minDate.toLocaleDateString('cs-CZ')} - ${maxDate.toLocaleDateString('cs-CZ')}</p>`;
                }
            }
            container.innerHTML = info;
        }

        function updateTable() {
            const data = getCurrentData();
            if (!data) return;
            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');
            const visibleCols = data.columns.filter(c => c !== 'dateObject');
            tableHead.innerHTML = '<tr>' + visibleCols.map(col => `<th>${col}</th>`).join('') + '</tr>';
            const startIndex = (currentPage - 1) * itemsPerPage;
            const pageData = data.filteredData.slice(startIndex, startIndex + itemsPerPage);
            tableBody.innerHTML = pageData.map(row => '<tr>' + visibleCols.map(col => `<td>${row[col] || ''}</td>`).join('') + '</tr>').join('');
            updatePagination();
        }

        function updatePagination() {
            const data = getCurrentData();
            if (!data) return;
            const totalPages = Math.ceil(data.filteredData.length / itemsPerPage);
            const pagination = document.getElementById('pagination');
            if (totalPages <= 1) { pagination.innerHTML = ''; return; }
            let html = '';
            if (currentPage > 1) html += `<button onclick="changePage(${currentPage - 1})">‚Üê</button>`;
            for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
                html += `<button class="${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
            }
            if (currentPage < totalPages) html += `<button onclick="changePage(${currentPage + 1})">‚Üí</button>`;
            pagination.innerHTML = html;
        }

        function changePage(page) { currentPage = page; updateTable(); }
        function changeItemsPerPage() { 
            itemsPerPage = parseInt(document.getElementById('itemsPerPage').value);
            localStorage.setItem('itemsPerPage', itemsPerPage);
            currentPage = 1; 
            updateTable(); 
        }
        
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            applyFilters();
        }
        
        function setDateRange(rangeType) {
            const endDate = new Date();
            let startDate = new Date();
            if (rangeType === 'last7days') {
                startDate.setDate(endDate.getDate() - 7);
            } else if (rangeType === 'thisMonth') {
                startDate.setDate(1);
            } else if (rangeType === 'lastMonth') {
                startDate = new Date(endDate.getFullYear(), endDate.getMonth() - 1, 1);
                endDate = new Date(endDate.getFullYear(), endDate.getMonth(), 0);
            }
            
            // Format to YYYY-MM-DD
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            applyFilters();
        }


        function applyFilters() {
            const data = getCurrentData();
            if (!data) return;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            // Fix for valueAsDate being off by one day due to timezone
            const startDate = startDateInput.value ? new Date(startDateInput.value + 'T00:00:00') : null;
            const endDate = endDateInput.value ? new Date(endDateInput.value + 'T23:59:59') : null;

            data.filteredData = data.allData.filter(row => {
                const textMatch = Object.values(row).some(val => val && val.toString().toLowerCase().includes(searchTerm));
                const rowDate = row.dateObject;
                if (!startDate && !endDate) return textMatch;
                if (!rowDate) return false;
                
                const startMatch = !startDate || rowDate >= startDate;
                const endMatch = !endDate || rowDate <= endDate;
                return textMatch && startMatch && endMatch;
            });
            currentPage = 1;
            updateTable();
        }
        
        // --- Charting ---
        function getChartColors() {
            const isDarkMode = document.body.classList.contains('dark-mode');
            return {
                textColor: isDarkMode ? '#e0e0e0' : '#333',
                gridColor: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
            };
        }
        
        function handleChartClick(event, elements, chart) {
            if (elements.length > 0) {
                const clickedIndex = elements[0].index;
                const clickedLabel = chart.data.labels[clickedIndex];
                document.getElementById('searchInput').value = clickedLabel;
                applyFilters();
                switchTab('table');
            }
        }
        
        function renderOverviewChart() {
            const data = getCurrentData();
            if (!data) return;

            const ctx = document.getElementById('overviewChart').getContext('2d');
            let chartData, chartOptions, chartType;

            if (data.currentMode === 'refrigeration') {
                const tempCol = getTemperatureColumn(data);
                const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
                if (!tempCol || !dateCol) return;
                
                chartType = 'line';
                const plotData = data.allData.filter(r => r.dateObject);

                chartData = {
                    labels: plotData.map(r => r.dateObject),
                    datasets: [{
                        label: `Teplota (${tempCol})`,
                        data: plotData.map(r => parseFloat(String(r[tempCol]).replace(',', '.'))),
                        borderColor: 'var(--primary-color)',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true,
                        tension: 0.2,
                        pointRadius: 0,
                    }]
                };
                 chartOptions = {
                    scales: {
                        x: { 
                            type: 'time', 
                            time: { unit: 'day' },
                            adapters: {
                                date: {
                                    locale: window.dateFnsLocaleCs
                                }
                            }
                        }
                    }
                };
            } else {
                // Default chart for other data types
                const categorical = data.categoricalColumns[0];
                const numerical = data.numericColumns[0];
                if (!categorical || !numerical) return;
                
                chartType = 'bar';
                const aggregatedData = data.allData.reduce((acc, row) => {
                    const category = row[categorical] || 'N/A';
                    acc[category] = (acc[category] || 0) + parseFloat(String(row[numerical]).replace(',', '.'));
                    return acc;
                }, {});

                chartData = {
                    labels: Object.keys(aggregatedData),
                    datasets: [{
                        label: `Souƒçet ${numerical} podle ${categorical}`,
                        data: Object.values(aggregatedData),
                        backgroundColor: 'var(--primary-color)',
                    }]
                };
                chartOptions = {};
            }

            if (overviewChartInstance) overviewChartInstance.destroy();
            
            const colors = getChartColors();
            overviewChartInstance = new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    ...chartOptions,
                    plugins: { legend: { labels: { color: colors.textColor } } },
                    scales: {
                        ...chartOptions.scales,
                        x: { ...chartOptions.scales?.x, ticks: { color: colors.textColor }, grid: { color: colors.gridColor } },
                        y: { ...chartOptions.scales?.y, ticks: { color: colors.textColor }, grid: { color: colors.gridColor } }
                    },
                    onClick: (event, elements) => handleChartClick(event, elements, overviewChartInstance)
                }
            });
        }


        function updateChartUI() {
            const data = getCurrentData();
            if (!data) return;
            const chartType = document.getElementById('chartType').value;
            const xAxisSelect = document.getElementById('xAxis');
            const yAxisSelect = document.getElementById('yAxis');
            let xOptions = '', yOptions = '';
            
            const dateCol = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));

            switch(chartType) {
                case 'pie': case 'doughnut':
                    xOptions = data.categoricalColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                    yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                    break;
                case 'scatter':
                    xOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                    yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
                    break;
                default: // line, bar
                    let allXOptions = [...data.categoricalColumns];
                    if(dateCol) allXOptions.unshift(dateCol);
                    xOptions = allXOptions.map(c => `<option value="${c}">${c}</option>`).join('');
                    yOptions = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
            }
            xAxisSelect.innerHTML = xOptions;
            yAxisSelect.innerHTML = yOptions;
            updateChart();
        }

        function calculateLinearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            const n = data.length;
            data.forEach(({x, y}) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        function updateChart() {
            const data = getCurrentData();
            if (!data) return;
            const ctx = document.getElementById('mainChart').getContext('2d');
            const chartType = document.getElementById('chartType').value;
            const xCol = document.getElementById('xAxis').value;
            const yCol = document.getElementById('yAxis').value;
            const showTrendline = document.getElementById('showTrendline').checked;

            if (!xCol || !yCol) return;

            let labels, values;
            const chartData = data.filteredData;
            
            const dateColName = data.columns.find(c => c.toLowerCase().includes('datum') || c.toLowerCase().includes('logged'));
            const isTimeSeries = xCol === dateColName;

            if (['pie', 'doughnut'].includes(chartType)) {
                const aggregated = chartData.reduce((acc, row) => {
                    const key = row[xCol] || 'N/A';
                    const value = parseFloat(String(row[yCol]).replace(',', '.'));
                    if(!isNaN(value)) {
                       acc[key] = (acc[key] || 0) + value;
                    }
                    return acc;
                }, {});
                labels = Object.keys(aggregated);
                values = Object.values(aggregated);
            } else if (isTimeSeries) {
                 labels = chartData.map(r => r.dateObject).filter(Boolean);
                 values = chartData.map(r => parseFloat(String(r[yCol]).replace(',', '.')));
            } else {
                labels = chartData.map(r => r[xCol]);
                values = chartData.map(r => parseFloat(String(r[yCol]).replace(',', '.')));
            }
            
            const datasets = [{
                label: `${yCol} podle ${xCol}`,
                data: values,
                backgroundColor: chartType === 'line' ? 'rgba(0, 122, 255, 0.1)' : 'var(--primary-color)',
                borderColor: 'var(--primary-color)',
                fill: chartType === 'line',
                tension: 0.1
            }];

            if (showTrendline && (chartType === 'line' || chartType === 'scatter')) {
                const trendData = chartData.map((row, index) => ({
                    x: isTimeSeries && row.dateObject ? row.dateObject.getTime() : index,
                    y: parseFloat(String(row[yCol]).replace(',', '.'))
                })).filter(p => p.x != null && !isNaN(p.x) && !isNaN(p.y));
                
                if (trendData.length > 1) {
                    const { slope, intercept } = calculateLinearRegression(trendData);
                    datasets.push({
                        label: 'Trendov√° ƒç√°ra',
                        data: trendData.map(p => ({ x: p.x, y: slope * p.x + intercept })),
                        type: 'line',
                        borderColor: 'var(--danger-color)',
                        fill: false,
                        pointRadius: 0
                    });
                }
            }

            if (mainChartInstance) mainChartInstance.destroy();
            const colors = getChartColors();
            mainChartInstance = new Chart(ctx, {
                type: chartType,
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: (chartType !== 'pie' && chartType !== 'doughnut') ? {
                        x: { 
                            type: isTimeSeries ? 'time' : 'category',
                            ticks: { color: colors.textColor }, 
                            grid: { color: colors.gridColor },
                            adapters: {
                                date: {
                                    locale: window.dateFnsLocaleCs
                                }
                            }
                        },
                        y: { ticks: { color: colors.textColor }, grid: { color: colors.gridColor } }
                    } : {},
                    plugins: { legend: { labels: { color: colors.textColor } } },
                     onClick: (event, elements) => handleChartClick(event, elements, mainChartInstance)
                }
            });
        }

        // --- Specific Analysis Tabs ---
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'analytics') updateAdvancedAnalytics();
            else if (tabName === 'comparison') updateComparisonView();
        }
        
        function updateComparisonView() {
            const container = document.getElementById('comparisonContent');
            const loadedDatasets = datasets.filter(d => d);
            
            let tableHtml = `<div class="widget"><h3>Srovn√°n√≠ metrik</h3><div class="table-wrapper"><table class="summary-table"><thead><tr><th>Metrika</th>`;
            loadedDatasets.forEach(ds => {
                tableHtml += `<th>${ds.fileName}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';
            
            const metrics = ['Celkem z√°znam≈Ø', 'Unik√°tn√≠ch beden', 'Aktivn√≠ch senzor≈Ø'];
            metrics.forEach(metric => {
                tableHtml += `<tr><td><strong>${metric}</strong></td>`;
                loadedDatasets.forEach(ds => {
                    let value = 'N/A';
                    if (ds.currentMode === 'sensor') {
                        const validData = ds.allData.filter(d => (d.stateCode === '1' || d.Status === '1') && d.sensor !== '0');
                        if (metric === 'Celkem z√°znam≈Ø') value = validData.length;
                        if (metric === 'Unik√°tn√≠ch beden') value = new Set(validData.map(d => d.EAN)).size;
                        if (metric === 'Aktivn√≠ch senzor≈Ø') value = new Set(validData.map(d => d.sensor)).size;
                    } else {
                        if (metric === 'Celkem z√°znam≈Ø') value = ds.allData.length;
                    }
                    tableHtml += `<td>${value}</td>`;
                });
                tableHtml += '</tr>';
            });
            tableHtml += '</tbody></table></div></div>';

            let chartHtml = `<div class="widget" style="margin-top:20px;"><h3>Porovn√°n√≠ vyt√≠≈æenosti</h3><div class="chart-container" style="height: 400px;"><canvas id="comparisonChart"></canvas></div></div>`;
            container.innerHTML = tableHtml + chartHtml;

            // Render comparison chart
            const chartCtx = document.getElementById('comparisonChart').getContext('2d');
            const colors = ['#007AFF', '#34C759', '#FF9500'];
            const chartDatasets = loadedDatasets.map((ds, index) => {
                const hourlyData = {};
                ds.allData.forEach(d => {
                    if (d.hour !== undefined) hourlyData[d.hour] = (hourlyData[d.hour] || 0) + 1;
                });
                return {
                    label: ds.fileName,
                    data: Array.from({length: 24}, (_, i) => hourlyData[i] || 0),
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '33',
                    fill: true,
                    tension: 0.2
                };
            });
            
            if(comparisonChartInstance) comparisonChartInstance.destroy();
            comparisonChartInstance = new Chart(chartCtx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 24}, (_, i) => `${String(i).padStart(2,'0')}:00`),
                    datasets: chartDatasets
                },
                options: { responsive: true, maintainAspectRatio: false }
            });
        }
        
        function populateAnalyticsSelector() {
            const data = getCurrentData();
            if (!data) return;
            const select = document.getElementById('analyticsColumn');
            const currentVal = select.value;
            
            const options = data.numericColumns.map(c => `<option value="${c}" ${c === currentVal ? 'selected' : ''}>${c}</option>`).join('');
            select.innerHTML = options;
        }

        function updateAdvancedAnalytics() {
            const data = getCurrentData();
            if (!data) return;
            
            populateAnalyticsSelector();
            
            const container = document.getElementById('analyticsContent');
            const selectedColumn = document.getElementById('analyticsColumn').value;

            if (data.currentMode === 'refrigeration') {
                 if(selectedColumn) {
                    container.innerHTML = generateRefrigerationAnalytics(selectedColumn);
                 } else {
                    container.innerHTML = `<div class="message error">Vyberte pros√≠m ƒç√≠seln√Ω sloupec pro anal√Ωzu.</div>`;
                 }
            }
            else if (data.currentMode === 'sensor') container.innerHTML = generateSensorAnalytics();
            else container.innerHTML = `<div style="text-align:center; padding: 40px;">Pro tento typ dat nen√≠ dostupn√° ≈æ√°dn√° pokroƒçil√° anal√Ωza.</div>`;
        }

        function generateRefrigerationAnalytics(tempCol) {
            const data = getCurrentData();
            const alarmCol = data.columns.find(c => c.toLowerCase().includes('alarm'));
            const defrostCol = data.columns.find(c => c.toLowerCase().includes('defrosting'));
            
            let tempStatsHtml = '<p>Teplotn√≠ data nebyla nalezena.</p>';
            let timeOutOfRangeHtml = '';

            if (tempCol) {
                const temps = data.allData.map(row => {
                    return {
                        value: parseFloat(String(row[tempCol]).replace(',', '.')),
                        date: row.dateObject
                    }
                }).filter(t => !isNaN(t.value) && t.date);
                
                if (temps.length > 0) {
                    tempStatsHtml = `
                        <p><strong>Pr≈Ømƒõr:</strong> ${(temps.map(t=>t.value).reduce((a, b) => a + b, 0) / temps.length).toFixed(2)}¬∞C</p>
                        <p><strong>Minimum:</strong> ${Math.min(...temps.map(t=>t.value)).toFixed(2)}¬∞C</p>
                        <p><strong>Maximum:</strong> ${Math.max(...temps.map(t=>t.value)).toFixed(2)}¬∞C</p>
                    `;

                    // Calculate time out of range (-18¬∞C)
                    const safeTemp = -18;
                    let outOfRangeMillis = 0;
                    for(let i = 1; i < temps.length; i++) {
                        if (temps[i-1].value > safeTemp && temps[i].value > safeTemp) {
                            // Assuming data points are sequential and time difference is meaningful
                            const timeDiff = temps[i].date.getTime() - temps[i-1].date.getTime();
                            // Only add if the time difference is reasonable (e.g., less than an hour) to avoid summing across large gaps
                            if (timeDiff < 3600000) {
                                outOfRangeMillis += timeDiff;
                            }
                        }
                    }
                    const totalMinutes = Math.round(outOfRangeMillis / (1000 * 60));
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    timeOutOfRangeHtml = `<p><strong>ƒåas nad -18¬∞C:</strong> <span style="font-weight:bold; color: var(--danger-color);">${hours}h ${minutes}m</span></p>`;
                }
            }

            let stateAnalysisHtml = '';
            if (defrostCol) {
                 const defrostingTime = data.allData.filter(r => String(r[defrostCol]).toLowerCase() === 'true').length * 5; // Assuming 5 min intervals, might need adjustment
                 stateAnalysisHtml += `<p><strong>Celkov√Ω ƒças odmrazov√°n√≠:</strong> ${Math.floor(defrostingTime / 60)}h ${defrostingTime % 60}m</p>`;
            }
             if (alarmCol) {
                const totalAlarms = data.allData.filter(r => r[alarmCol] !== '0' && r[alarmCol] !== '' && r[alarmCol] != null).length;
                stateAnalysisHtml += `<p><strong>Poƒçet alarm≈Ø:</strong> <span style="color: ${totalAlarms > 0 ? 'var(--danger-color)' : 'var(--success-color)'}; font-weight: bold;">${totalAlarms}</span></p>`;
            }

            return `<div class="widget"><h3>üå°Ô∏è Anal√Ωza chlad√≠rny: ${data.fileName}</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div style="background: var(--bg-color); padding: 15px; border-radius: 8px;">
                        <h4>Teplotn√≠ statistiky (${tempCol || 'N/A'})</h4>
                        ${tempStatsHtml}
                        ${timeOutOfRangeHtml}
                    </div>
                    <div style="background: var(--bg-color); padding: 15px; border-radius: 8px;">
                        <h4>Anal√Ωza stav≈Ø</h4>
                        ${stateAnalysisHtml}
                    </div>
                </div>
            </div>`;
        }

        function generateSensorAnalytics() {
            const data = getCurrentData();
            const validData = data.allData.filter(d => (d.stateCode === '1' || d.Status === '1') && d.sensor !== '0');
            const hourlyData = {};
            validData.forEach(d => {
                if (d.hour !== undefined && d.hour !== null) {
                    hourlyData[d.hour] = (hourlyData[d.hour] || 0) + 1;
                }
            });

            const totalValid = validData.length;
            const hourlyStats = Object.entries(hourlyData).map(([hour, count]) => ({
                hour: parseInt(hour),
                count,
                percentage: (count / totalValid * 100).toFixed(1)
            })).sort((a,b) => a.hour - b.hour);

            const maxHour = hourlyStats.reduce((max, h) => h.count > max.count ? h : max, {count: -1, hour: -1});
            const minHour = hourlyStats.reduce((min, h) => h.count < min.count ? h : min, {count: Infinity, hour: -1});
            
            let summaryHtml = `<p>Nebylo nalezeno dostatek dat pro anal√Ωzu vyt√≠≈æenosti.</p>`;
            if (maxHour.hour !== -1 && minHour.hour !== -1) {
                summaryHtml = `
                    <p><strong>Celkem z√°znam≈Ø:</strong> ${data.allData.length} (${totalValid} validn√≠ch)</p>
                    <p><strong>Nejaktivnƒõj≈°√≠ hodina:</strong> ${formatHourRange(maxHour.hour)} (${maxHour.count} beden)</p>
                    <p><strong>Nejm√©nƒõ aktivn√≠ hodina:</strong> ${formatHourRange(minHour.hour)} (${minHour.count} beden)</p>
                    <p><strong>Doporuƒçen√≠:</strong> Provoz je nejvy≈°≈°√≠ v ${formatHourRange(maxHour.hour)}. Zva≈æte pos√≠len√≠ zdroj≈Ø v tomto ƒçase. Naopak, v ${formatHourRange(minHour.hour)} je provoz minim√°ln√≠.</p>
                `;
            }

            let html = `<div class="widget" style="margin-bottom:20px;"><h3>üìà Souhrn anal√Ωzy</h3>${summaryHtml}</div>`;
            
            html += `<div class="widget"><h3>üìã Detailn√≠ p≈ôehled</h3><div class="table-wrapper"><table class="summary-table">
                <thead><tr><th>Hodina</th><th>Poƒçet beden</th><th>Pod√≠l z celku</th><th>Vizu√°ln√≠ p≈ôehled</th></tr></thead><tbody>`;

            hourlyStats.forEach(h => {
                html += `<tr class="clickable-row" onclick="toggleHourDetail(${h.hour})">
                    <td>${formatHourRange(h.hour)}</td>
                    <td>${h.count}</td>
                    <td>${h.percentage}%</td>
                    <td><div class="bar-viz" style="width: ${h.percentage}%;"></div></td>
                </tr>
                <tr id="detail-for-hour-${h.hour}" class="hour-detail" style="display: none;"><td colspan="4"></td></tr>`;
            });

            html += `</tbody></table></div></div>`;
            return html;
        }

        function toggleHourDetail(hour) {
            const detailRow = document.getElementById(`detail-for-hour-${hour}`);
            if (!detailRow) return;

            if (detailRow.style.display === 'none') {
                if (detailRow.querySelector('td').innerHTML === '') {
                    const detailHtml = generateHourDetailHtml(hour);
                    detailRow.querySelector('td').innerHTML = detailHtml;
                }
                detailRow.style.display = 'table-row';
            } else {
                detailRow.style.display = 'none';
            }
        }

        function generateHourDetailHtml(hour) {
            const data = getCurrentData();
            const recordsForHour = data.allData
                .filter(row => row.hour === hour && (row.stateCode === '1' || row.Status === '1'))
                .sort((a, b) => a.timestamp.localeCompare(b.timestamp));

            if (recordsForHour.length === 0) {
                return '<p style="padding: 10px; text-align: center;">Pro tuto hodinu nebyly nalezeny ≈æ√°dn√© validn√≠ z√°znamy.</p>';
            }

            let html = `<div style="padding: 15px; background: var(--bg-color);"><table class="summary-table">
                        <thead><tr><th>P≈ôesn√Ω ƒças</th><th>EAN</th><th>Senzor</th><th>Smƒõr</th></tr></thead><tbody>`;
            
            recordsForHour.forEach(d => {
                const dirClass = d.direction === 'IN' ? 'direction-IN' : (d.direction === 'OUT' ? 'direction-OUT' : 'direction-NA');
                html += `<tr>
                    <td>${(d.datum_cas || '').split(' ')[1] || ''}</td>
                    <td>${d.EAN || ''}</td>
                    <td>${d.sensor || ''}</td>
                    <td><span class="sensor-direction ${dirClass}">${d.direction || 'N/A'}</span></td>
                 </tr>`;
            });

            html += `</tbody></table></div>`;
            return html;
        }

        // --- Export & Reset ---
        function exportCSV() {
            const data = getCurrentData();
            if (!data || data.filteredData.length === 0) return showMessage('‚ùå ≈Ω√°dn√° data k exportu', 'error');
            const visibleCols = data.columns.filter(c => c !== 'dateObject');
            let csv = visibleCols.join(',') + '\n';
            data.filteredData.forEach(row => {
                csv += visibleCols.map(col => `"${(row[col] || '').toString().replace(/"/g, '""')}"`).join(',') + '\n';
            });
            downloadFile(csv, `export_${data.fileName}.csv`, 'text/csv');
        }

        function exportJSON() {
            const data = getCurrentData();
            if (!data || data.filteredData.length === 0) return showMessage('‚ùå ≈Ω√°dn√° data k exportu', 'error');
            const dataToExport = data.filteredData.map(row => {
                const newRow = {...row};
                delete newRow.dateObject;
                return newRow;
            });
            const content = JSON.stringify(dataToExport, null, 2);
            downloadFile(content, `export_${data.fileName}.json`, 'application/json');
        }

        async function exportPDF() {
            showMessage('Generuji PDF report...', 'success');
            const { jsPDF } = window.jspdf;
            const dashboard = document.getElementById('dashboardGrid');
            const canvas = await html2canvas(dashboard, {
                backgroundColor: document.body.classList.contains('dark-mode') ? '#1e1e1e' : '#ffffff',
                scale: 2
            });
            const imgData = canvas.toDataURL('image/png');
            
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
            
            pdf.setFontSize(22);
            pdf.text('Report anal√Ωzy dat', pdfWidth / 2, 20, { align: 'center' });
            pdf.setFontSize(12);
            pdf.text(`Soubor: ${getCurrentData().fileName}`, 15, 30);
            pdf.text(`Datum exportu: ${new Date().toLocaleString('cs-CZ')}`, 15, 36);

            pdf.addImage(imgData, 'PNG', 15, 45, pdfWidth - 30, pdfHeight - 30);
            
            pdf.save(`report_${getCurrentData().fileName}.pdf`);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function resetApp() { window.location.reload(); }
        function clearAll() { if (confirm('Opravdu chcete vymazat v≈°echna data a zaƒç√≠t znovu?')) resetApp(); }
        
        // --- ML Functions ---
        function updateMLSelects() {
            const data = getCurrentData();
            if (!data) return;
            const predictionSelect = document.getElementById('predictionColumn');
            const anomalySelect = document.getElementById('anomalyColumn');
            const options = data.numericColumns.map(c => `<option value="${c}">${c}</option>`).join('');
            
            if (predictionSelect) predictionSelect.innerHTML = `<option value="">Vyberte sloupec...</option>${options}`;
            if (anomalySelect) anomalySelect.innerHTML = `<option value="">Vyberte sloupec...</option>${options}`;
        }

        function findAnomalies() {
            const data = getCurrentData();
            if (!data) return;
            const resultsContainer = document.getElementById('anomalyResults');
            const column = document.getElementById('anomalyColumn').value;
            if (!column) {
                showMessage('Vyberte pros√≠m sloupec pro anal√Ωzu anom√°li√≠.', 'error');
                return;
            }

            const values = data.allData.map(row => parseFloat(row[column])).filter(v => !isNaN(v)).sort((a, b) => a - b);
            if (values.length < 4) {
                resultsContainer.innerHTML = `<p style="padding: 10px; text-align: center;">Nedostatek dat pro detekci anom√°li√≠.</p>`;
                return;
            }

            const q1 = values[Math.floor(values.length / 4)];
            const q3 = values[Math.floor((values.length / 4) * 3)];
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;

            const anomalies = data.allData.filter(row => {
                const value = parseFloat(row[column]);
                return !isNaN(value) && (value < lowerBound || value > upperBound);
            });

            if (anomalies.length === 0) {
                resultsContainer.innerHTML = `<div class="message success">Nebyly nalezeny ≈æ√°dn√© v√Ωznamn√© anom√°lie.</div>`;
                return;
            }

            let html = `<div class="table-wrapper" style="margin-top: 15px;"><table class="summary-table">
                            <thead><tr><th>#</th><th>Hodnota (${column})</th><th>Stav</th></tr></thead><tbody>`;
            
            anomalies.forEach((row, index) => {
                const value = parseFloat(row[column]);
                const status = value < lowerBound ? 'P≈ô√≠li≈° n√≠zk√°' : 'P≈ô√≠li≈° vysok√°';
                html += `<tr>
                            <td>${index + 1}</td>
                            <td>${value}</td>
                            <td><span class="sensor-direction direction-OUT">${status}</span></td>
                         </tr>`;
            });

            html += `</tbody></table></div>`;
            resultsContainer.innerHTML = html;
        }

        function predictTrend() {
            const data = getCurrentData();
            if (!data) return;
            const column = document.getElementById('predictionColumn').value;
            const steps = parseInt(document.querySelector('#ml-content .ml-section:first-child input[type="number"]').value, 10);
            const resultContainer = document.getElementById('predictionResult');
            
            if (!column) {
                showMessage('Vyberte sloupec pro predikci.', 'error');
                return;
            }

            const dataPoints = data.allData
                .map((row, index) => ({ x: index, y: parseFloat(row[column]) }))
                .filter(p => !isNaN(p.y));

            if (dataPoints.length < 2) {
                showMessage('Nedostatek dat pro vytvo≈ôen√≠ predikce.', 'error');
                return;
            }

            const { slope, intercept } = calculateLinearRegression(dataPoints);

            const lastX = dataPoints[dataPoints.length - 1].x;
            const predictedPoints = [];
            for (let i = 1; i <= steps; i++) {
                const newX = lastX + i;
                predictedPoints.push({
                    x: newX,
                    y: slope * newX + intercept
                });
            }

            resultContainer.style.display = 'block';
            resultContainer.innerHTML = '<canvas id="predictionChart"></canvas>';
            const ctx = document.getElementById('predictionChart').getContext('2d');

            if (predictionChartInstance) {
                predictionChartInstance.destroy();
            }

            const colors = getChartColors();

            predictionChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: `P≈Øvodn√≠ data (${column})`,
                            data: dataPoints,
                            borderColor: 'var(--primary-color)',
                            tension: 0.1
                        },
                        {
                            label: `Predikce (${steps} krok≈Ø)`,
                            data: [dataPoints[dataPoints.length - 1], ...predictedPoints],
                            borderColor: 'var(--danger-color)',
                            borderDash: [5, 5],
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'ƒåasov√Ω krok / Index', color: colors.textColor },
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        },
                        y: {
                            title: { display: true, text: `Hodnota (${column})`, color: colors.textColor },
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: colors.textColor
                            }
                        }
                    }
                }
            });
        }

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
             applySavedTheme();
             document.getElementById('uploadNewFileBtn').addEventListener('click', showUploadSection);
             
             new Sortable(document.getElementById('dashboardGrid'), {
                animation: 150,
                ghostClass: 'sortable-ghost'
            });
        });
        window.addEventListener('error', e => showMessage(`‚ùå Nastala chyba: ${e.message || 'Nezn√°m√° chyba'}`, 'error'));
    </script>
</body>
</html>
